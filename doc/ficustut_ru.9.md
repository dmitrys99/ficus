Модули

Каждый источник Ficus рассматривается компилятором как модуль. Большие проекты обычно распределяются по нескольким файлам, представляющим осмысленные компоненты, которые можно повторно использовать, импортируя один модуль в другой. По конвенции названия модулей, предназначенных для импорта, начинаются с прописной латинской буквы и содержат смешанный регистр, например, MyModule.fx. Если вы создали файл MyModule.fx и определили в нём некоторые функции, вы сможете импортировать его в другой модуль и обращаться к функционалу с помощью точечной нотации:

// MyModule.fx
...
fun fact(n: int) = if n <= 1 {1} else {n*fact(n-1)}

// где-то в начале файла a_script.fx
import MyModule
...
val n = 5
println(f"{n}! = {MyModule.fact(n)}")

Стандартная библиотека Ficus включает ряд полезных модулей, реализующих общую функциональность. Мы будем обращаться к некоторым из них в ходе руководства. Компилятор Ficus автоматически подключает возможности стандартного модуля Builtins в каждый скомпилированный модуль, поэтому, если вы используете функциональность из Builtins, нет необходимости добавлять инструкцию import Builtins в ваш код. Аналогичным образом нет необходимости явно импортировать следующие стандартные модули, так как они включены по умолчанию: Array, Char, List, Math, String, Vector.

Директива import — единственный способ работы с модулями, и она имеет две разновидности:

    Импорт с переименованием (import-as):

// например, импорт с переименованием
import SomeVeryLongModuleName as m

    Частичный импорт (from-import):

// импорт выбранной функциональности
from MyModule import fact
val f5 = fact(5)

// или импорт всего содержимого
from MyModule import *

Если функция перегружена, инструкция from-import импортирует все функции с указанным именем. Если нужно импортировать какую-то конкретную функцию из модуля, можно воспользоваться следующим подходом:

import File
val fopen = File.open
// в случае перегруженных функций
// нужно явно указать тип
val dsin = (Math.sin : double->double)

Так как значения в Ficus неизменяемы, компилятор не видит разницы между dsin и Math.sin: double->double в приведённом выше примере, и использование псевдонима не влияет на производительность.
Сложные модули

(Внимание разработчикам): в настоящее время реализована только часть предлагаемой функциональности. Поддерживается организация модулей в подпапках, но нет поддержки файла __init__.fx.

Разрабатывая крупные приложения или фреймворки, быстро понимаешь, что плоской структуры модулей (один модуль на файл) недостаточно. Один из способов обойти ограничение — ввести особую систему именования, например, назвать модули так: DeepLearning_Nonlin_ReLU.fx, что помогает группировать модули. Лучшим решением станет использование механизма сложных модулей в Ficus, который сходен с механизмом Python. Предположим, мы хотим создать сложную структуру модулей, обеспечивающую интерфейс к библиотеке компьютерного зрения OpenCV, состоящей из нескольких частей (Core, Imgproc и т.д.). Нам также хотелось бы включить экспериментальную коллекцию Contrib, содержащую несколько компонент (DNN, Text и т.д.).

Структура проекта может выглядеть следующим образом:

ficus/lib # родительская директория библиотек, хотя размещать пакеты можно в любом удобном месте,
            # главное настроить переменную среды ficus_PATH
            # или использовать опцию -I с компилятором
    OpenCV/
        __init__.fx # необязательный прокси-модуль для импорта всей функциональности
        Core.fx # ядро библиотеки
        Imgproc.fx # работа с изображением
        ...
        Contrib/
            __init__.fx # необязательный прокси-модуль для импорта всей функциональности
            Bioinspired.fx # глубокое обучение
            Text.fx # детектирование текста
            ...

В вашем приложении вы можете:

    импортировать всё целиком:

import OpenCV as cv // псевдоним cv не обязателен

    импортировать отдельные части:

import OpenCV.Contrib.Text
import OpenCV.Contrib.Bioinspired as cv_bio

    импортировать конкретные функции:

from OpenCV.Imgproc import Canny

Следует помнить несколько моментов при создании сложной структуры модулей:

    Механизм организации сложных модулей устроен просто и не предполагает никакой магии с пространствами имён или зависимостями. Вы разрабатываете индивидуальные модули как обычно и вручную импортируете всё необходимое. При импорте отдельных частей сложной структуры в другие модули нужно указывать полные пути, разделённые точкой:

// OpenCV.Imgproc
import OpenCV.Core // или использовать "import OpenCV.Core as Core",
                    // чтобы вводить удобные псевдонимы

    Следует избегать цикличных зависимостей между модулями; Ficus сообщит об ошибке в таком случае.
    Файлы __init__.fx необязательны. Если, скажем, файл OpenCV/Contrib/__init__.fx отсутствует, вы всё равно можете импортировать OpenCV.Contrib.Text, но не сможете импортировать весь пакет OpenCV.Contrib; то есть наличие файла __init__.fx позволяет пользователям импортировать целую директорию.
    Содержимое файла __init__.fx свободно формируется автором пакета. Существуют два популярных подхода, которые можно комбинировать:
        Объединить всё в единую "пространство имён":

// OpenCV/__init__.fx
from OpenCV.Core import *
from OpenCV.Imgproc import *
...

  Пользователь сможет писать:

import OpenCV as cv
cv.dft(...)
cv.Canny(...)

    Выступать в роли "пакета импорта":

// OpenCV/__init__.fx
import OpenCV.Core as Core
import OpenCV.Imgproc as Imgproc
...

  Тогда пользователь сможет писать:

import OpenCV as cv
cv.Core.dft(...)
cv.Imgproc.Canny(...)

    Предоставлять различные варианты посредством специальных прокси-модулей, например:

// OpenCV/All.fx
import OpenCV.Core as Core
import OpenCV.Imgproc as Imgproc
...

  Тогда пользователь сможет писать:

import OpenCV.All as cv
cv.Core.dft(...)
cv.Imgproc.Canny(...)

Предпроцессинг, условная компиляция, конфигурации

Сразу после лексического анализа и перед синтаксическим разбором каждый модуль Ficus подвергается этапу предпроцессинга. На этом этапе можно включать, исключать и модифицировать любую часть модуля, включая инструкции import и прочие директивы, основываясь на текущих условиях окружения и необходимой конфигурации.
Определение символов препроцессора

Прежде всего, компилятор Ficus поддерживает опцию -D, предназначенную для определения символов препроцессора. Её синтаксис выглядит так:

    -D symbol_name или
    -D symbol_name=value

где value может быть:

    Булевым значением: true (или его синонимы TRUE, ON, on), false (или его синонимы FALSE, OFF, off);
    Целым числом;
    Строкой текста.

Если значение не указано, оно принимается равным true.

Определённые символы автоматически вставляются в начало каждого скомпилированного модуля в виде директив:

@define symbol_name value

Пользователь также может самостоятельно определять свои символы с помощью директив:

@define symbol_name preprocessor_expression

где preprocessor_expression — арифметическое выражение, допускающее литералы, ранее определённые символы и встроенные функции и операции:

    abs(x) — абсолютное значение;
    int(x) — приведение строки или булевского значения к числу;
    string(x) — приведение булевского или числового значения к строке;
    defined(x) — истинно, если символ x определён;
    f"..." — интерполяция строк, см. раздел Текстовые строки.

Противоположная операция — удаление определения:

@undef symbol_name

которая снимает определение, так что последующий вызов defined(symbol_name) возвращает false, пока символ вновь не будет определён.
Условная компиляция

Некоторые части скомпилированного модуля можно включать или исключать с помощью условий, аналогичных стилю C:

@if preprocessor_expr
    ...
[@elif another_preprocessor_expr
    ...] // необязательные блоки elseif
[@else
    ...] // необязательный блок else
@endif // закрывающая директива, соответствующая @if

Также возможны укороченные формы:

@ifdef symbol_name // эквивалентно @if defined(symbol_name)
...

@ifndef symbol_name // эквивалентно @if !defined(symbol_name)
...

Сообщение проблем

Сообщение о проблемах также аналогично препроцессору C:

// выводит предупреждение "<location>: warning: <результат выражения>"
// и продолжает компиляцию
@warning preprocessor_expression

// выводит ошибку "<location>: error: <результат выражения>"
// и прерывает компиляцию
@error preprocessor_expression

Аргументами должны быть текстовые строки или выражения, возвращающие строки.

Вот гипотетический короткий пример. Скажем, у нас есть модули для графического интерфейса под Win32 (win32_ui.fx) и Linux (linux_ui.fx):

// win32_ui.fx: интерфейс Win32, зависящий от Windows API
...

// linux_ui.fx: интерфейс на основе GTK+, с тем же API, что и Win32 UI
...

Теперь мы можем создать кросс-платформенный код:

// my_app.fx
@if Platform == "Win32"
import win32_ui as ui
@elif Platform == "Linux"
import linux_ui as ui
@else
@error "недоступная платформа"
@endif

ui.make_button("Click me!", fun() {println("Hello!")})
ui.run()

Его можно скомпилировать на разных платформах командой:

ficus -app -D Platform=<целевая_платформа> my_app.fx

Замещение результатов

Помимо условной компиляции, результаты выражений препроцессора можно подставлять непосредственно в финальный код с помощью специальной директивы @{preprocessor_expression}, например:

// myexample.fx
...
@define x 5
@define y x + opt
val x = @{y*y}
println(x)

Компилируя с опцией ficus -D opt=1 myexample.fx, программа выведет 36.

Отметим, что символы препроцессора существуют только на стадии препроцессинга. Их имена не конфликтуют и не пересекаются с обычными именами (значения, функции, типы, исключения, интерфейсы и т.д.), определёнными в вашей программе.
Объектно-ориентированное программирование

Несмотря на то, что Ficus в первую очередь ориентирован на функциональные языки, он включает некоторые элементы объектно-ориентированного программирования, предназначенные упростить разработку повторно используемых компонентов и сделать нотацию более удобной. Интерфейсы, представленные в следующем разделе, предлагают классическую и более эффективную альтернативу замыканиям для ряда ситуаций.

Класс в Ficus определяется почти так же, как запись или вариант:

class [optional_type_parameters] class_name
    [ : list_of_implemented_interfaces ]
{
    члены класса
}

// или
class [optional_type_parameters] class_name
    [ : list_of_implemented_interfaces ] =
    | Tag1 [: T1]
    | Tag2 [: T2]
    ...

Основные отличия заключаются в следующем:

    Используется ключевое слово class вместо type;
    За именем класса может идти список реализуемых интерфейсов;
    Символ = перед фигурной скобкой пропущен.

Вот пример класса прямоугольника и его использования:

class 't Rect
{
    x: int
    y: int
    width: int
    height: int
}

// основной конструктор; имя произвольное
fun new_rect(x: 't, y: 't, w: 't, h: 't)
    Rect {x=x, y=y, width=w, height=h}

// дополнительный конструктор
fun new_square(x: 't, y: 't, size: 't) =
    Rect {x=x, y=y, width=size, height=size}

fun Rect.area() = self.width*self.height

fun Rect.contains((pt_x, pt_y): ('t, 't)) =
    self.x <= pt_x < self.x + self.width &&
    self.y <= pt_y < self.y + self.height

// переопределим дефолтное преобразование в строку
fun string(r: Rect) =
    f"rect {{ x={r.x}, y={r.y}, width={r.width}, height = {r.height} }}"

// создаём экземпляр типа 'int Rect';
// экземпляр создаётся автоматически
val r = new_rect(5, 9, 10, 10)
val pt = (12, 12)
// используем некоторые методы
println(f"площадь прямоугольника={r.area()},\nсодержит точку {pt}?: {r.contains(pt)}")

Обращаю внимание на несколько особенностей, продемонстрированных в примере:

    Определение классов, даже обобщённых, настолько же просто, как и других типов в Ficus.
    Класс автоматически получает конструктор записи или вариантный конструктор. Помимо этого можно определить один или несколько альтернативных конструкторов. Например, если вы реализуете класс, представляющий глубокую нейронную сеть, основной конструктор мог бы инициализировать её как пустую модель, а другой конструктор мог бы загружать модель из файла.
    Методы объявляются так же, как обычные функции, где имя класса предшествует названию метода, и они получают доступ к членам класса с помощью нотации self.member.
    Методы объявляются вне тела класса, но должны находиться в том же модуле.

В стандартной библиотеке есть несколько общих классов для файлов, различных структур данных и прочего. Вот законченный пример чтения текстового файла и сбора статистики по самым употребительным словам в тексте:

import Hashmap
import Sys
import File

// создаём экземпляр класса Hashmap.t: ключ=string, данные=int
val wordmap = Hashmap.empty(1024, "", 0)
val separators = " \t,.:;?!()[]{}=><+-/*\\'\"|\n"

val (f, isstdin) = match Sys.arguments() {
    | fname :: _ => (File.open(fname, "rt"), false)
    | _ => (File.stdin, true)
    }

try {
    // читаем данные из параметра командной строки
    // или из stdin, если не указана команда
    while !f.eof() {
        val s = f.readln()
        // извлекаем слова из строки
        val words = s.tokens(fun (c) {separators.contains(c)})
        // обновляем карту частот
        for w <- words {
            val idx = wordmap.find_idx_or_insert(w)
            wordmap.table[idx].data += 1
        }
    }
    val n0 = wordmap.size()
    val n = min(n0, 30)
    val header = f"Самые частые {n} слов в файле:"
    print(header + "\n" + "-"*length(header) + "\n")
    // извлекаем статистику
    val wpairs = wordmap.list()
    // сортируем слова по частоте убывания
    val sorted_wpairs = wpairs.sort(
        fun ((w1, n1): (string, int), (w2, n2): (string, int))
        {n1 > n2 || n1 == n2 && w1 < w2})
    for (w, count)@i <- sorted_wpairs {
        println(f"{w}: {count}")
        if i+1 >= n {break}
    }
} finally {
    if !isstdin {f.close()}
}

Как видно, это не объектно-ориентированная программа, но она использует классы File.t и Hashmap.t для достижения цели.