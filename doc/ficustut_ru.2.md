# Условные выражения

Наиболее общий вид условного выражения в Ficus представлен следующим образом:

```
if условие1 {
  выражения1 ...
} /* необязательные ветви else if: */
else if условие2 {
  выражения2 ...
} else if ...
/* необязательная ветвь else */ else {
  else-выражения ...
}
```

Другими словами, существует обязательная ветвь `then` (с выражениями `выражения1`), необязательная ветвь `else` и ноль или более промежуточных ветвей `else if`. Все ветви должны иметь одинаковый тип: либо `void` (классический стиль императивных языков), либо непустые типы. Отсутствие ветви `else` считается сокращённой записью для `else {}`. В таком случае остальные ветви обязаны быть типа `void`. Рассмотрим несколько примеров:

```
// ошибка: ветвь if имеет тип 'double', ветвь else имеет тип 'void'
val y = if x >= 0. {sqrt(x)}
        else {
           println(f"x={x} отрицательное")
        }
val y = if x >= 0. {sqrt(x)}
        else {
           // нормально, так как 'throw' совместимо с любым типом
           throw Fail(f"x={x} отрицательное")
        }
import File
val y = if x >= 0. {sqrt(x)}
        else {
           // эта форма тоже правильная, мы регистрируем ошибку
           File.println(File.stderr, f"x={x} отрицательное")
           // затем возвращаем некоторое дефолтное значение
           0.
        }
// использование цепочки условий для реализации бизнес-логики
fun days_in_month(month: int, year: int) =
   if month < 1 || month > 12 { throw OutOfRangeError }
   else if month == 1 || month == 3 || month == 5 || month == 7 ||
           month == 8 || month == 10 || month == 12 {31}
   else if month == 4 || month == 6 || month == 9 || month == 11 {30}
   else if year % 4 != 0 ||
        (year % 100 == 0 && year % 400 != 0) {28}
   else {29}
```

## Цикл `while`

Это классическая конструкция цикла, выполняющаяся до тех пор, пока указанное условие остаётся истинным:

```
while условие { тело_цикла ... }
```

Пример использования:

```
import File
val f = File.open("fiblist.fx", "rt")
var count = 0
// читаем текст из файла, считаем ненулевые строки
while !f.eof() {
   val str = f.readln()
   count += str.strip() != ""
}
println(count)
```

Тип тела цикла обязательно должен быть `void`, и весь цикл также имеет тип `void`.

## Цикл `for`

Ещё одна важная конструкция — это цикл по некоторому интервалу значений, двумерной сетке или коллекции:

```
// итерация по диапазону
for idx1 <- старт_знач1:конец_знач1[:шаг1]
 for idx2 <- старт_знач2:конец_знач2[:шаг2] ... {
   выражения ...
}
```

В первом варианте цикла `for` вводится идентификатор `idx1` типа `int`, принимающий последовательно значения:

```
старт_знач1, старт_знач1 + шаг1, старт_знач1 + шаг1*2, ...
```

до достижения границы `конец_знач1`. Если шаг не указан, принимается значение шага `1`. Шаги могут быть отрицательными, тогда цикл выполняется минимум один раз, если `старт_знач` больше конечного значения. Приведём пример:

```
// подготовка таблицы для быстрого подсчета расстояния Хэмминга
fun popcount(n: int) =
    if n > 0 {1 + popcount(n & (n - 1))}
    else {0}
val hamming_lut = array(256, 0u8)
for i <- 0:256 { hamming_lut[i] = uint8(popcount(i)) }
println(hamming_lut)

// вывод треугольника Паскаля
val n = 10
val triangle = array((n, n), 0)
for i <- 0:n for j <- 0:i+1 {
    val x = if j == 0 || i == 0 {1}
            else {triangle[i-1, j-1] + triangle[i-1, j]}
    triangle[i, j] = x
    print(f"{x} ")
    if j == i {print("\n")}
}
```

Заметим, что внутренние циклы могут зависеть от текущих значений внешнего цикла.

Вторая форма цикла for предназначена для перебора коллекций:

```
// перебор коллекций
for эл1 <- колл1
   [for эл2 <- колл2 ...] {
   выражения
}
```

Поддерживаемые коллекции включают списки, строки, массивы и векторы:

```
// гистограмма изображений
val histogram = array(256, 0)
val w = 640, h = 480
val image = array((h, w), 0u8)
val rng = RNG(0x12345u64)
// заполняем изображение случайными значениями
for y <- 0:h
   for x <- 0:w {
      image[y, x] = rng.uniform(0u8, 255u8))
   }

// Итерация по пикселям изображения
// вложенный цикл автоматически организуется компилятором
for pix <- image {
    histogram[pix] += 1
}

// проверка, является ли строка числом
val str = "12345"
var isint = true
for c <- str {
   if !('0' <= c <= '9') {
      isint = false
      break // выход раньше окончания цикла
   }
}
```

Во вложенных циклах можно смешивать проход по диапазону и коллекциям.

Также возможен одновременный проход по нескольким коллекциям, т.е. если есть две и более коллекции и нужно обработать соответствующие пары/н-ки элементов, например:

```
for val1 <- coll1, val2 <- coll2 ... { выражения ... }
```

Так, например, легко рассчитать расстояние Хэмминга между двумя векторами:

```
val a = array(16, 0u8)
val b = array(16, 0u8)
... // инициализация a и b, и подготовка таблицы расстояний Хамминга
var hamming_dist = 0
for x <- a, y <- b { hamming_dist += hamming_lut[x ^ y] }
```

При попытке параллельно пройти по коллекциям разного размера возникнет исключение `SizeMismatchError`.

Тело цикла `for`, как и результат, должно иметь тип `void`. Если тип тела отличается от `void`, компилятор выдаёт ошибку.

### Получение индекса текущего элемента с помощью `@`

Иногда полезно получать индекс текущего обрабатываемого элемента помимо самого элемента. Например, при печати списка чисел мы хотим ставить запятую между всеми элементами кроме первого. Обычно это делается так:

```
for i <- 0:n { if i > 0 {print ", "}; print(a[i]) }
```

Однако такая конструкция менее эффективна и сложнее воспринимается визуально. Особенно неудобно это для списков, где `a[i]` отсутствует вовсе.

Специальная синтаксическая конструкция решает проблему:

```
for x@i <- mylist { if i > 0 {print ", "}; print(x) }
```

Таким образом, после значения можно добавить `@индекс`, и этот индекс будет установлен автоматически. Это внутреннее свойство компилятора, позволяющее ускорить работу с индексами без дополнительной нагрузки на память и производительность.

Индексация доступна и для многомерных массивов:

```
// вычислить рамку вокруг изображения, содержащую все ненулевые пиксели
fun bounding_box(image: uint8 [,])
{
    var minx = 1000000, maxx = -1
    var miny = 1000000, maxy = -1
    for pix@(y, x) <- image {
        if pix != 0 {
            minx = min(minx, x); maxx = max(maxx, x)
            miny = min(miny, y); maxy = max(maxy, y)
        }
    }
    if maxx >= 0 { (minx, miny, maxx-minx+1, maxy-miny+1) }
    else { (0,0,0,0) }
}
```

Все индексы и сами элементы остаются неизменными на каждой итерации. Попытка изменить индекс приведет к ошибке:

```
for v@offset <- datastream {
   // ошибка: индекс offset не может быть изменён вручную
   if v == 0 {offset += 10}
}
```

