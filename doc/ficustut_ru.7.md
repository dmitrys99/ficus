# Списки

Неизменяемый односвязный список играет важную роль во многих функциональных языках начиная с Лиспа. Списки состоят из так называемых конс-клеток (CONS клеток), каждая из которых представляет собой пару (головной элемент, хвостовой элемент), где головной элемент — это некоторый элемент списка, а хвостовой элемент — либо указатель на оставшуюся часть списка, либо пустой список [] (нулевой указатель). В Ficus все элементы списка обязаны иметь один и тот же тип (в отличие от динамически типизированных языков, таких как Lisp). Например, список чисел [1,2,3][1,2,3] выглядит так:

+-----+   +-----+   +-----+
|  1  +-->|  2  +-->|  3  |---+
+-----+   +-----+   +-----+   |
                             -+-

То есть, связи идут только в одном направлении — от головы к хвосту, а последний элемент имеет пустой указатель («null»).

Такие списки оказываются удивительно мощным инструментом. Изначально в оригинальном Lisp единственным доступным типом данных был именно список, использовавшийся для представления любых видов данных, от иерархических структур до сложных программ на самом Lisp.

Списки в Ficus можно выразить двумя способами:

val list123 = [:: 1, 2, 3]
// или
val list123 = 1 :: 2 :: 3 :: []

Оператор :: называется CONS (поэтому списки называются CONS-списками). Он берет скалярный головной элемент (элемент некоторого типа T) и список tl (типа T list) и формирует новую клетку (hd, tl), создавая таким образом новый список. Заметьте, что операция :: не изменяет исходный список tl — он остаётся неизменённым, потому что списки в Ficus неизменяемы. Из-за этого свойства список нельзя ни добавить в середину, ни удалить элемент посередине, ни присоединить элемент в конец. Хотя поначалу это кажется серьёзным ограничением, преимущество такой реализации заключается в сохранении предыдущих состояний списка:

val a = "a" :: []
val b = "b" :: a
val c = "c" :: b
println(b) // напечатает ["b", "a"]

Это свойство полезно для анализа кода, отладки и обеспечивает безопасность, поскольку операции со списками не имеют побочных эффектов (за исключением случая, когда элементы сами по себе изменяемы, например, массивы или ссылки). Списки относятся к функциональным структурам данных. Другой хороший пример неизменяемой структуры — красно-чёрное дерево поиска, которое мы рассмотрим позднее в разделе Суммарные типы или варианты.

Ещё одно важное достоинство таких списков — практически любые возможные операции над ними можно выразить с использованием четырёх примитивных действий (при желании можно записать операцию в форме List.foo(l[, args]) вместо l.foo([args])):

    l.empty() — возвращает истину, если список пуст. Можно также сравнить список с пустым списком: l == [] или l != [], что транслируется в высокоэффективный код.
    l.hd() — извлекает первый элемент первого CONS-элемента, то есть получает голову списка. Если список пуст, возникает исключение NullListError.
    l.tl() — извлекает второй элемент первого CONS-элемента, то есть хвост списка. Если список пуст, возникает исключение NullListError.
    x :: l — создаёт новый список путём добавления нового головного элемента x к существующему списку l.

Пример простого использования:

val l0 = [:: 1, 2, 3]

// добавляет квадраты чисел в обратном порядке
val fold l = l0 for i <- 0:5 {i*i :: l}

// ошибка: все элементы должны быть одного типа
val err1 = 3.14 :: l

// получение третьего (счёт идёт с нуля) элемента списка
val x = l.tl().tl().tl().hd() // 0

// функция для получения n-го элемента списка
fun list_nth(l: 't list, n: int): 't =
    if n < 0 || l == [] {
        throw OutOfRangeError
    } else if n == 0 {
        l.hd()
    } else {
        list_nth(l.tl(), n-1)
    }

print(list_nth(l, 5)) // выводит 2
print(list_nth(l, 100)) // выбросит OutOfRangeError

Теперь покажем, как можно реализовать полезные функции обработки списков с использованием четырёх базовых операций. Эти функции обладают общими свойствами:

    они универсальны и работают с любыми списками;
    они не вызывают побочных эффектов;
    они написаны в хвостово-рекурсивном стиле, следовательно, выполняются за линейное время O(N) и занимают постоянное пространство стека O(1);
    большинство из них уже определены в стандартных модулях Builtins и List, но приведены здесь исключительно для иллюстрации и образовательных целей.

Начнём с простой и широко применяемой функции обращения списка, которая также служит вспомогательной функцией для других операций:

// Реализация List.rev(l)
fun list_rev(l: 't list): 't list
{
    fun list_rev_(l: 't list, result: 't list): 't list =
        if l.empty() {result} else {list_rev_(l.tl(), l.hd() :: result)}
    list_rev_(l, [])
}

Эта реализация демонстрирует распространённый приём в функциональных программах — вместо цикла мы определяем внутреннюю хвостово-рекурсивную функцию, принимающую текущее состояние ввода и промежуточный результат, а затем вызывает саму себя для продолжения итерации.

Рассмотрим следующую полезную функцию — подсчёт длины списка:

fun list_length_naive(l: 't list): int =
    if l.empty() {0} else {1 + list_length_naive(l.tl())}

Реализация проста, но у неё есть недостаток — она не является хвостово-рекурсивной, так как производит дополнительные операции после рекурсивного вызова самой себя. Следовательно, её невозможно преобразовать в цикл, и она расходует память в стеке пропорционально длине списка O(N). Решить проблему можно, применив технику, использованную в list_rev:

// Реализация l.length()
fun list_length(l: 't list): int
{
    fun list_length_(l: 't list, len: int) =
        if l.empty() {len} else {list_length_(l.tl(), 1 + len)}
    list_length_(l, 0)
}

Следующая важная функция — объединение списков, реализованная в модуле Builtins как перегруженный оператор +:

fun list_concat(la: 't list, lb: 't list): 't list
{
    fun list_concat_(rev_la: 't list, result: 't list): 't list =
        if rev_la.empty() {result}
        else {list_concat_(rev_la.tl(), rev_la.hd() :: result)}
    list_concat_(list_rev(la), lb)
}

Алгоритм действует иначе, чем простое добавление элементов второго списка в конец первого. Так как прямое добавление невозможно, элементы первого списка последовательно присоединяются к началу второго. Чтобы сохранить порядок, сначала инвертируется первый список.

Все рассмотренные выше функции схожи по структуре: проверяют, пуст ли список (или его текущий хвост), если да — возвращают итоговый результат, иначе выполняют обработку головки и делают рекурсивный вызов для хвоста. Рассмотрим универсальный метод, называемый foldl, который реализует такую схему в более общей форме:

// Реализация List.foldl()
fun list_foldl(l: 't list, f: ('t, 'res)->'res, res0: 'res): 'res =
    if l.empty() {res0} else {list_foldl(l.tl(), f(l.hd(), res0), f)}

При помощи foldl легко переписать реализацию предыдущей функции list_length():

fun list_length2(l: 't list) =
    list_foldl(l, 0, fun (_: 't, len: int) {1 + len})

Используя _ для обозначения неиспользуемых параметров, теперь нам редко придётся писать собственные рекурсивные функции для обработки списков. Однако иногда всё-таки потребуется выйти из цикла досрочно. Приведём другой общий случай:

// Реализация List.find()
// Возвращает первый элемент, удовлетворяющий предикату.
// Если подходящего элемента нет, возвращает None.
fun list_find(l: 't list, pred: 't->bool): 't? =
    if l.empty() {None}
    else {
        val x = l.hd()
        if pred(x) {Some(x)}
        else {list_find(l.tl(), pred)}
    }

val l = [:: 1, 2, 3]
val first_even = list_find(fun (x) {x % 2 == 0}, l)
println(if first_even.issome() {
        string(first_even.value())
    } else {
        "нечётных элементов не найдено"
    }) // выводит "2"

Ещё одна частая операция — отображение элементов списка с последующим формированием нового списка результатов:

// Реализация List.map()
fun list_map(l: 'a list, f: 'a->'b): 'b list =
    list_foldl(list_rev(l),
                fun (x: 'a, res: 'b list) {f(x) :: res},
                ([] : 'b list))

// альтернатива, не хвостово-рекурсивная,
// но не использующая обращение списка
fun list_map_alt(l: 'a list, f: 'a->'b): 'b list =
    if l == [] {[]} else {f(l.hd()) :: list_map_alt(l.tl(), f)}

val strs = [:: "1", "a", "2"]
// конвертирует строки в целые числа,
// некорректные строки заменяются на -1.
// Результат: [:: 1, -1, 2]
val nums = list_map(strs, fun (s: string) {s.to_int_or(-1)})

Отображение — это специальный случай свёртки, когда результатом является новый список. Аналогично можно переписать List.filter(), сохраняя только элементы, удовлетворяющие заданному условию.

Поскольку List.foldl() и List.map() столь распространены, в Ficus предусмотрены удобные сокращения с использованием оператора цикла и оператор свёртки, которые упрощают работу с этими функциями:

// Используем оператор свёртки вместо List.foldl()
fun list_length3(l: 't list): int = fold len=0 for x <- l {len+1}

// Используем генератор списков вместо List.map()
val nums = [:: for s <- strs {s.to_int_or(-1)}]

// Простая итерация по списку без построения результата
for s <- strs {
    println(s)
}

Хотя многие операции над списками легко реализуемы, стандартные модули (Builtins и List) предоставляют готовые решения для базовых функций. Вот полный перечень методов, доступных для списков:

    l.last() — возвращает последний элемент списка; выбрасывает исключение NullListError, если список пуст.
    l.nth(n) — возвращает n-й элемент списка.
    l.length() — возвращает длину списка.
    l.rev() — возвращает обращённый список.
    l.app(f) — применяет функцию f ко всем элементам списка. Функция должна возвращать void.
    l.map(f) — создаёт новый список, применяя функцию f к каждому элементу.
    l.foldl(f, v0) — сворачивает список в значение, используя функцию обновления f. Начальное значение результата — v0.
    l.array() — преобразует список в массив.
    l.all(pred) — возвращает true, если предикат истинен для всех элементов.
    List.all2(la, lb, pred) — аналогична List.all(), но применяется к двум спискам параллельно.
    l.exists(pred) — возвращает true, если предикат истинен хотя бы для одного элемента.
    l.mem(a) — возвращает true, если элемент a присутствует в списке.
    l.find_opt(pred) — возвращает первый элемент, для которого предикат истинен. Если подходящего элемента нет, возвращается None.
    l.assoc_opt(a) — для списка пар (aj,bj)(aj​,bj​) возвращает Some(b_j) для первой пары, где aj==aaj​==a. Если подходящей пары нет, возвращает None.
    l.filter(pred) — сохраняет только те элементы, для которых предикат истинен.
    ll.concat() — объединяет несколько списков. Существует несколько вариантов этой функции. Для соединения двух списков достаточно записать la + lb.
    List.zip(la, lb) — возвращает список пар, состоящий из соответствий элементов списков la и lb.
    lab.unzip() — противоположна List.zip(), возвращает кортеж из двух списков (la, lb).
    l.sort(lt) — сортирует список с помощью функции сравнения lt:

val a = [:: ("a", 5), ("c", 0), ("A", 1)]
// сортирует список пар по первому элементу;
// возвращает [:: ("A", 1), ("a", 5), ("c", 0)]
val b = a.sort(fun ((s1, n1): (string, int),
                (s2, n2): (string, int)) => s1 < s2)

Мы показали, как базовые операции над списками и некоторые другие алгоритмы можно выразительнее записывать с использованием механизма сопоставления с образцом.
Выбор между списком, вектором и массивом

(Будет дополнено более подробным обсуждением)

    Для многомерных плотных данных (2D, 3D, …) предпочтительны массивы.
    Используйте вектор, если необходим неизменяемый список, кроме случаев, когда требуется сопоставление с образцом, тогда лучше применять список.
    Несмотря на то, что доступ к элементам вектора выполняется за время O(1), он существенно медленнее, чем доступ к массиву. Последовательный доступ к элементам близок по скорости.
    Дополнительные затраты памяти заметны только для маленьких коллекций. Массивы требуют минимальных накладных расходов (0%), векторы — незначительных (несколько процентов), а списки заметно увеличивают потребление памяти и нагрузку на аллокатор.

Сопоставление с образцом

Механизм сопоставления с образцом активно используется в Ficus. Фактически, мы уже неоднократно сталкивались с его ограниченными формами в предыдущих разделах. Полноценная форма сопоставления реализуется с помощью оператора match, который похож на сильно расширенный оператор switch, присутствующий в классических языках наподобие C/C++ и Java. Его синтаксис следующий:

match expr {
| pattern1 => exprs1 // первая вертикальная черта после '{' необязательна
| pattern2 => exprs2
...
| patternN => exprsN
}

Таким образом, оператор берёт на входе выражение expr, вычисляет его и последовательно пытается сопоставить полученный результат с различными паттернами (каждый паттерн предварён символом |). После нахождения совпадения выполняется соответствующая цепочка выражений (назовём её действием). Если ни один шаблон не подходит, возбуждается исключение MatchError. Часто одинаковые действия соответствуют нескольким шаблонам, тогда их можно объединить. Проверка паттернов осуществляется сверху вниз.

Паттерны в Ficus можно представить как своего рода иерархические регулярные выражения, состоящие из двух компонентов (оба компонента необязательные):

    Часть, описывающая проверки, необходимые для успешного сопоставления значения с паттерном.
    Вторая часть описывает захватываемых переменных, если сопоставление успешно.

Формально паттерн может быть представлен как один из следующих видов (для удобства пояснений в дальнейшем будем придерживаться следующей формы описания: название-шаблона ДВОЕТОЧИЕ синтаксис-шаблона ТОЧКА Описание):

    Литеральный паттерн: одно из чисел, строкового литерала, булевого значения true, false или пустого списка []. Используется простое сравнение значения или его части с указанным шаблоном. Захват переменных отсутствует.
    Паттерн-заглушка: _. Подходит абсолютно любому значению и не захватывает никаких переменных. Зачем он нужен? Чаще всего заглушка полезна в случаях, когда нам неважна какая-то часть сложного паттерна, или когда хотим задать последнюю позицию в операторе match, соответствующую случаю "остальное".
    Идентификатор: имя_переменной. Начинается с маленькой буквы или подчёркивания. Здесь проверка отсутствует, захваченное значение сохраняется под именем имя_переменной и доступно в действиях.
    Кортежный паттерн: (паттерн1, паттерн2, ..., паттернN). Применяется к кортежеподобным данным размера N, элементы которого проверяются соответствующими паттернами. Совпадение считается успешным, если успешны все вложенные паттерны.
    Рекорд-паттерн: { поле1=паттерн1, ..., полеN=паттернN }. Предполагает, что значение должно быть рекордом, содержащим указанные поля. Остальные поля рекордов не проверяются и не захватываются (аналогично использованию заглушки _).
    Паттерн списка: головной_паттерн :: хвостовой_паттерн. Подразумевает, что значение — это список. Если список пуст, сопоставление неудачно, иначе голова списка проверяется на соответствие головному паттерну, а хвост — хвостовому паттерну.
    Паттерн захвата: паттерн as идентификатор. Сначала значение проверяется на соответствие указанному паттерну, если удачно, захваченная часть сохраняется под именем идентификатор.
    Условный паттерн: паттерн when условие. Сначала значение проверяется на соответствие паттерну, если совпадает, оценивается условие (может использовать захваченные переменные). Соответствие признаётся удачным, если условие истинно.
    Вариантный паттерн: Имя(паттерн1, ..., паттернN). Имя начинается с заглавной буквы, количество паттернов соответствует количеству параметров конструктора. В случае единственного параметра, если паттерн — литерал, заглушка или идентификатор, круглые скобки можно опустить. Что такое "вариант"? Узнаем в следующем разделе.
    Альтернативный паттерн: паттерн1 | паттерн2 | .... Сопоставление успешно, если успешно хотя бы один из перечисленных паттернов. Текущая версия компилятора Ficus не разрешает захват переменных в альтернативных паттернах.

Приведённые выше примеры позволяют составить представление о возможностях оператора match. Он способен заменить конструкцию switch в C и даёт гораздо больше возможностей. Посмотрим несколько примеров, демонстрирующих упрощённое применение операторов для обработки списков:

fun list_rev_pm(l: 't list): 't list
{
    fun rev_(l_in: 't list, l_out: 't list): 't list =
        match l_in {
        | x :: rest => rev_(rest, (x :: l_out))
        | [] => l_out
        }
    rev_(l, [])
}

// предыдущая реализация была представлена здесь для наглядности
fun list_foldl_pm(f: ('t, 'res)->'res, res0: 'res, l: 't list): 'res =
    match l {
    | x :: rest => list_foldl_case(f, f(x, res0), rest)
    | _ => res0
    }

Видим, что с помощью сопоставления с образцом и оператора :: удалось избавиться от методов empty(), hd() и tl()!

Финальная деталь касается сортировки списков. Очевидно, что эта задача не решается простым способом с помощью хвостово-рекурсивной функции, так как наилучший алгоритм сортировки — O(N log N). Возможны два подхода:

    Элементы списка перемещаются в массив, после чего применяется стандартный императивный алгоритм сортировки. Именно так поступают в текущей реализации, так как это самый эффективный подход.
    Существует чисто функциональный алгоритм сортировки слиянием с временной сложностью O(N log N), приведённый ниже. Сам алгоритм показан отдельно, а здесь приводится его схематичное описание:
        Реализуется вспомогательная функция merge, которая сливает две упорядоченные последовательности в одну.
        Исходный список длиной NN превращается в NN отдельных списков, каждый из которых содержит один элемент.
        Затем совершается log⁡(N)log(N) проходов по этому списку списков. На каждом проходе последовательно берутся две соседние последовательности и сливаются в одну. Итоговая сложность прохода — O(N), после каждого прохода длина списка уменьшается вдвое, а длина каждой последовательности удваивается.

Ниже приведена полная реализация алгоритма сортировки слиянием для списков:

/* mergeSort: процедура сортировки методом слияния, работающая за O(n log n).
Создаётся список списков, после чего эти списки сливаются до тех пор, пока не останется один.
*/
fun mergeSort(l: 't list, lt: ('t,'t)->bool): 't list =
    match l {
    | [] => []
    | l =>
        // функция сливает две упорядоченные последовательности
        fun merge(_: 't list, _: 't list): 't list
        {
            | ((a :: at) as l, (b :: bt) as r) =>
                if lt(a, b) {a :: merge(at, r)}
                else {b :: merge(l, bt)}
            | (l, []) => l
            | ([], r) => r
        }

        // проходит по списку [:: l0, l1, l2, ... ], сливает пары списков
        // на каждом проходе получаем (N+1)/2 списков удвоенной длины
        fun scan(_: 't list list): 't list list
        {
            | a :: b :: rest => merge(a, b) :: scan(rest)
            | l => l
        }

        // повторяем сканирование до тех пор, пока не останется один список
        fun loop(_: 't list list): 't list
        {
            | a :: [] => a
            | l => loop(scan(l))
        }
        // начинаем с списка одноэлементных списков
        loop([for a <- l {[a]}])
    }

Замечания по реализации:

    Внутри действия оператора match можно разместить большое количество дополнительного кода. Здесь показано три вложенные функции, помогающие структурировать решение и облегчить чтение кода.
    Если тело функции сводится к оператору match, принимающему все параметры функции, то можно сократить написание и исключить явное использование ключевого слова match.
    В функциональных программах, особенно при обработке символических данных, операторы match и рекурсия тесно связаны.
    Ранее рекомендовалось использовать хвостово-рекурсивные функции. В данной реализации функции merge и scan не являются хвостово-рекурсивными, так как их хвостово-рекурсивные аналоги порождают обращённые списки, а многократное обращение нежелательно. Здесь предпочтение отдаётся избыточному созданию узлов списка взамен увеличения потребления пространства стека.

Шаблоны захвата

Фактически оператор match — не единственное место, где применяются паттерны. Уже ранее встречались ограниченные формы паттернов, используемые в других частях кода. Ограниченность здесь подразумевает отсутствие проверок, иными словами, такие паттерны служат только для захвата значений. Ниже приведены примеры:

// распаковываем кватернион с помощью шаблона захвата
val (x, y, z, _) = q

// ошибка: левая сторона определения значения должна быть шаблоном захвата
val (1., y, z, _) = q

// захватываем границы рамки и статус отслеживания объекта
val { box, tracked } = obj
// ошибка: левая сторона определения значения должна быть шаблоном захвата
val { label=("car", _), box, tracked=true } = obj

// распаковываем пиксели при переборе изображения
val gray = [for (r, g, b) <- img {
        sat_uint8(round(r*0.299 + g*0.587 + b*0.114))
    }]

// перспективная проекция трёхмерной точки на плоскость
fun normalize((x, y, z): (float*3)) = (x/z, y/z)

Шаблоны захвата можно использовать в следующих случаях:

    формальные параметры функций;
    левые стороны определений значений и переменных;
    переменные цикла.
