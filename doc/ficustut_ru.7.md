# Списки

Неизменяемый односвязный список играет важную роль во многих функциональных языках, начиная с Лиспа. Списки состоят из так называемых CONS-ячеек (**CONS** cells), каждая из которых представляет собой пару `(hd, tl)`, где `hd` &ndash; это некоторый элемент списка, а `tl` &ndash; либо указатель на оставшуюся часть списка, либо пустой список `[]` (пустой указатель). В Ficus все элементы списка обязаны иметь один и тот же тип (в отличие от динамически типизированных языков, таких как Лисп). Например, список чисел 1, 2 и 3 выглядит так: 

![Список](images/list.png)

То есть, связи идут только в одном направлении &ndash; от головы к хвосту, а хвостовой указатель последнего элемента &ndash; пустой указатель (`null`). 

Такие списки оказываются удивительно мощным инструментом. Изначально в оригинальном Лисп единственным доступным типом данных был именно список, использовавшийся для представления любых видов данных, от иерархических структур до сложных программ на самом Лисп.

Списки в Ficus можно выразить двумя способами:

```
val list123 = [:: 1, 2, 3]
// или
val list123 = 1 :: 2 :: 3 :: []

// Операция :: правоассоциативна,
// так что второе выражение эквивалентно
val list123 = 1 :: (2 :: (3 :: []))

```

Оператор `::` называется CONS (поэтому списки называются CONS-списками). Он берет скалярный головной элемент (элемент некоторого типа `T`) и список `tl` (типа `T list`) и формирует новую ячейку `(hd, tl)`, создавая таким образом новый список. Заметьте, что операция `::` не изменяет исходный список `tl` &ndash; он остаётся неизменённым, потому что списки в Ficus неизменяемы. Из-за этого свойства список нельзя ни добавить в середину, ни удалить элемент посередине, ни присоединить элемент в конец. Хотя поначалу это кажется серьёзным ограничением, преимущество такой реализации заключается в сохранении предыдущих состояний списка:

```
val a = "a" :: []
val b = "b" :: a
val c = "c" :: b
println(b) // напечатает ["b", "a"]
```

Это свойство полезно для анализа кода, отладки и обеспечивает безопасность, поскольку операции со списками не имеют побочных эффектов (за исключением случая, когда элементы сами по себе изменяемы, например, массивы или ссылки). Списки относятся к функциональным структурам данных. Другой хороший пример неизменяемой структуры &ndash; красно-чёрное дерево поиска, которое мы рассмотрим позднее в разделе [Варианты](). 

Ещё одно важное достоинство таких списков &ndash; практически любые возможные операции над ними можно выразить с использованием четырёх примитивных действий (при желании можно записать операцию в форме `List.foo(l[, args])` вместо `l.foo([args])`): 

<table>
<tr>
	<th>Функция</th>
	<th>Описание</th>
</tr>
<tr>
	<td><code>l.empty()</code></td>
	<td>Возвращает истину, если список пуст.<br/>Можно также сравнить список с пустым списком: <code>l == []</code> или <code>l != []</code>, что транслируется в высокоэффективный код.</td>
</tr>
<tr>
	<td><code>l.hd()</code></td>
	<td>Извлекает первый элемент первой CONS-ячейки, то есть получает голову списка.<br/>Если список пуст, возникает исключение <code>NullListError</code>.</td>
</tr>
<tr>
	<td><code>l.tl()</code></td>
	<td>Извлекает второй элемент первой CONS-ячейки, то есть хвост списка.<br/>Если список пуст, возникает исключение <code>NullListError</code>.</td>
</tr>
<tr>
	<td><code>x :: l</code></td>
	<td>создаёт новый список путём добавления нового головного элемента <code>x</code> к существующему списку <code>l</code></td>
</tr>
</table>

Пример простого использования:

```
val l0 = [:: 1, 2, 3]

// добавляет квадраты чисел в обратном порядке
val fold l = l0 for i <- 0:5 {i*i :: l}

// ошибка: все элементы должны быть одного типа
val err1 = 3.14 :: l

// получение третьего (счёт идёт с нуля) элемента списка
val x = l.tl().tl().tl().hd() // 0

// функция для получения n-го элемента списка
fun list_nth(l: 't list, n: int): 't =
    if n < 0 || l == [] {
        throw OutOfRangeError
    } else if n == 0 {
        l.hd()
    } else {
        list_nth(l.tl(), n-1)
    }

print(list_nth(l, 5)) // выводит 2
print(list_nth(l, 100)) // выбросит OutOfRangeError
```

Теперь покажем, как можно реализовать полезные функции обработки списков с использованием четырёх базовых операций. Эти функции обладают общими свойствами: 

* они универсальны и работают с любыми списками;
* они не имеют побочных эффектов;
* они написаны с использованием хвостовой рекурсии, следовательно, выполняются за линейное время `O(N)` и занимают постоянное пространство стека `O(1)`;
* большинство из них уже определены в стандартных модулях `Builtins` и `List`, но приведены здесь исключительно для иллюстрации и в образовательных целях.

Начнём с простой и широко применяемой функции обращения списка, которая также служит вспомогательной функцией для других операций:

```
// Реализация List.rev(l)
fun list_rev(l: 't list): 't list
{
    fun list_rev_(l: 't list, result: 't list): 't list =
        if l.empty() {result} else {list_rev_(l.tl(), l.hd() :: result)}
    list_rev_(l, [])
}
```

Эта реализация демонстрирует распространённый приём в функциональных программах &ndash; вместо цикла мы определяем внутреннюю рекурсивную функцию, принимающую текущее состояние ввода и промежуточный результат, а затем вызывает саму себя для продолжения итерации.

Рассмотрим следующую полезную функцию &ndash; подсчёт длины списка:

```
fun list_length_naive(l: 't list): int =
    if l.empty() {0} else {1 + list_length_naive(l.tl())}
```

Реализация проста, но у неё есть недостаток &ndash; здесь нет хвостовой рекурсии, так как фукнция производит дополнительные операции после рекурсивного вызова самой себя. Следовательно, её невозможно преобразовать в цикл, и она расходует память в стеке пропорционально длине списка `O(N)`. Решить проблему можно, применив технику, использованную в `list_rev`:

```
// Реализация l.length()
fun list_length(l: 't list): int
{
    fun list_length_(l: 't list, len: int) =
        if l.empty() {len} else {list_length_(l.tl(), 1 + len)}

    list_length_(l, 0)
}
```

Следующая важная функция &ndash; объединение списков, реализованная в модуле Builtins как перегруженный оператор `+`:

```
fun list_concat(la: 't list, lb: 't list): 't list
{
    fun list_concat_(rev_la: 't list, result: 't list): 't list =
        if rev_la.empty() {result}
        else {list_concat_(rev_la.tl(), rev_la.hd() :: result)}

    list_concat_(list_rev(la), lb)
}
```

Алгоритм действует иначе, чем простое добавление элементов второго списка в конец первого. Так как прямое добавление невозможно, элементы первого списка последовательно присоединяются к началу второго. Чтобы сохранить порядок, сначала инвертируется первый список. 

Все рассмотренные выше функции схожи по структуре: проверяют, пуст ли список (или его текущий хвост), если да &ndash; возвращают итоговый результат, иначе выполняют обработку головы списка и делают рекурсивный вызов для хвоста списка. Рассмотрим универсальный метод, называемый `foldl`, который реализует такую схему в более общей форме:

```
// Реализация List.foldl()
fun list_foldl(l: 't list, f: ('t, 'res)->'res, res0: 'res): 'res =
    if l.empty() {res0} else {list_foldl(l.tl(), f(l.hd(), res0), f)}
```

При помощи `foldl` легко переписать реализацию предыдущей функции `list_length()`:

```
fun list_length2(l: 't list) =
    list_foldl(l, 0, fun (_: 't, len: int) {1 + len})
```

Обратите внимание, что для неиспользуемых параметров используется обозначение `_`.

Используя `list_foldl()`/`List.foldl()`, вам редко нужно будет писать собственные рекурсивные функции для обработки списков. Один из таких редких случаев &ndash; необходимость досрочного выхода из цикла обработки списка. 

```
// Реализация List.find()
// Возвращает первый элемент, удовлетворяющий предикату.
// Если подходящего элемента нет, возвращает None.
fun list_find(l: 't list, pred: 't->bool): 't? =
    if l.empty() {None}
    else {
        val x = l.hd()
        if pred(x) {Some(x)}
        else {list_find(l.tl(), pred)}
    }

val l = [:: 1, 2, 3]
val first_even = list_find(fun (x) {x % 2 == 0}, l)
println(if first_even.issome() {
        string(first_even.value())
    } else {
        "нечётных элементов не найдено"
    }) // выводит "2"
```

Ещё одна частая операция &ndash; функциональное отображение элементов списка с последующим формированием нового списка результатов:

```
// Реализация List.map()
fun list_map(l: 'a list, f: 'a->'b): 'b list =
    list_foldl(list_rev(l),
                fun (x: 'a, res: 'b list) {f(x) :: res},
                ([] : 'b list))

// альтернатива, без хвостовой рекурсии,
// но не использующая обращение списка
fun list_map_alt(l: 'a list, f: 'a->'b): 'b list =
    if l == [] {[]} else {f(l.hd()) :: list_map_alt(l.tl(), f)}

val strs = [:: "1", "a", "2"]
// конвертирует строки в целые числа,
// некорректные строки заменяются на -1.
// Результат: [:: 1, -1, 2]
val nums = list_map(strs, fun (s: string) {s.to_int_or(-1)})
```

Отображение &ndash; это специальный случай свёртки, когда результатом является новый список. Аналогично можно переписать `List.filter()`, сохраняя только элементы, удовлетворяющие заданному условию. 

Поскольку `List.foldl()` и `List.map()` столь распространены, в Ficus предусмотрены удобные сокращения с использованием оператора цикла и оператор свёртки, которые упрощают работу с этими функциями: 

```
// Используем оператор свёртки вместо List.foldl()
fun list_length3(l: 't list): int = fold len=0 for x <- l { len + 1 }

// Используем генератор списков вместо List.map()
val nums = [:: for s <- strs {s.to_int_or(-1)}]

// Простая итерация по списку без построения результата
for s <- strs {
    println(s)
}

```

Хотя многие операции над списками легко реализуемы, стандартные модули (Builtins и List) предоставляют готовые решения для базовых функций. Вот полный перечень методов, доступных для списков: 

<table>
<tr>
	<th>Функция</th>
	<th>Описание</th>
</tr>
<tr>
	<td><code>l.last()</code></td>
	<td>возвращает последний элемент списка<br/>Выбрасывает исключение <code>NullListError</code>, если список пуст</td>
</tr>
<tr>
	<td><code>l.nth(i)</code></td>
	<td>Возвращает i-й элемент списка</td>
</tr>
<tr>
	<td><code>l.length()</code></td>
	<td>Возвращает длину списка</td>
</tr>
<tr>
	<td><code>l.rev()</code></td>
	<td>Возвращает обращённый список (список в обратном порядке)</td>
</tr>
<tr>
	<td><code>l.app(f)</code></td>
	<td>применяет функцию <code>f</code> ко всем элементам списка. Функция должна возвращать <code>void</code></td>
</tr>
<tr>
	<td><code>l.map(f)</code></td>
	<td>Создаёт новый список, применяя функцию <code>f</code> к каждому элементу исходного списка</td>
</tr>
<tr>
	<td><code>l.foldl(f, v0)</code></td>
	<td>Сворачивает список в значение, используя функцию <code>f</code> для преобразования элементов. Свертка начинается со значения <code>v0</code></td>
</tr>
<tr>
	<td><code>l.array()</code></td>
	<td>Преобразует список в массив</td>
</tr>
<tr>
	<td><code>l.all(pred)</code></td>
	<td>Возвращает <code>true</code>, если предикат выполняется для всех элементов</td>
</tr>
<tr>
	<td><code>List.all2(la, lb, pred)</code></td>
	<td>Аналогична <code>List.all()</code>, но применяется к двум спискам</td>
</tr>
<tr>
	<td><code>l.exists(pred)</code></td>
	<td>Возвращает <code>true</code>, если предикат выполняется хотя бы для одного элемента</td>
</tr>
<tr>
	<td><code>l.mem(a)</code></td>
	<td>Возвращает <code>true</code>, если элемент <code>a</code> присутствует в списке</td>
</tr>
<tr>
	<td><code>l.find_opt(pred)</code></td>
	<td>Возвращает первый элемент, для которого выполняется предикат. Если подходящего элемента нет, возвращается <code>None</code></td>
</tr>
<tr>
	<td><code>l.assoc_opt(a)</code></td>
	<td>Для списка пар <code>(a<sub>i</sub>, b<sub>i</sub>)</code> возвращает <code>Some(b<sub>i</sub>)</code> для первой пары, где <code>a<sub>i</sub> == a</code>. Если подходящей пары нет, возвращает <code>None</code></td>
</tr>
<tr>
	<td><code>l.filter(pred)</code></td>
	<td>Сохраняет только те элементы в списке, для которых выполняется предикат.</td>
</tr>
<tr>
	<td><code>l.concat()</code></td>
	<td>Объединяет несколько списков. Существуют разные варианты этой функции.<br/>Для соединения двух списков достаточно записать <code>la + lb</code></td>
</tr>
<tr>
	<td><code>List.zip(la, lb)</code></td>
	<td>возвращает список пар, состоящий из соответствий элементов списков <code>la</code> и <code>lb</code></td>
</tr>
<tr>
	<td><code>l.unzip()</code></td>
	<td>Противоположна <code>List.zip()</code>, возвращает кортеж из двух списков <code>(la, lb)</code></td>
</tr>
<tr>
	<td><code>l.sort(lt)</code></td>
	<td>Сортирует список с помощью функции сравнения <code>lt</code></td>
</tr>
</table>

```
val a = [:: ("a", 5), ("c", 0), ("A", 1)]
// сортирует список пар по первому элементу;
// возвращает [:: ("A", 1), ("a", 5), ("c", 0)]
val b = a.sort(fun ((s1, n1): (string, int),
                (s2, n2): (string, int)) => s1 < s2)
```

Мы показали, как базовые операции над списками и некоторые другие алгоритмы можно выразительнее записывать с использованием механизма сопоставления с образцом. 

## Выбор между списком, вектором и массивом

** (Будет дополнено более подробным обсуждением) ** 

* Для многомерных плотных данных (2D, 3D, …) предпочтительны массивы.
* Используйте `vector`, если необходим неизменяемый список, кроме случаев, когда требуется сопоставление с образцом, тогда лучше применять список.
* Несмотря на то, что доступ к элементам вектора выполняется за время `O(1)`, произвольный доступ к вектору существенно медленнее, чем доступ к массиву. Последовательный доступ к элементам вектора близок по скорости к элементам массива.
* Дополнительные затраты памяти заметны только для маленьких коллекций. Массивы требуют минимальных накладных расходов (0%), векторы &ndash; незначительных (несколько процентов), а списки заметно увеличивают потребление памяти и нагрузку на аллокатор. Поэтому для огромных массивов использование массивов или векторов предпочтительнее, поскольку использование списков создает значительную нагрузку на аллокатор и требует заметно больше памяти.

# Сопоставление с образцом

В Ficus активно используется механизм сопоставления с образцом. Фактически, мы уже неоднократно сталкивались с его ограниченными формами в предыдущих разделах. Полноценная форма сопоставления реализуется с помощью оператора `match`, похожий на сильно расширенный оператор `switch`, присутствующий в классических языках вроде C/C++ и Java. Его синтаксис: 

```
match expr {
| pattern1 => exprs1 // первая вертикальная черта после '{' необязательна
| pattern2 => exprs2
...
| patternN => exprsN
}
```

Таким образом, оператор берёт на входе выражение `expr`, вычисляет его и последовательно пытается сопоставить полученный результат с различными шаблонами (образцами). Каждый образец предваряется символом `|`. После нахождения совпадения выполняется соответствующая цепочка выражений (назовём её действием). Если ни один образец не подходит, выбрасывается исключение `MatchError`. Часто одинаковые действия соответствуют нескольким образцам, тогда их можно объединить. Проверка образцов осуществляется сверху вниз.

Образцы в Ficus можно представить как своего рода иерархические регулярные выражения, состоящие из двух компонентов (оба компонента необязательные):

* первая часть описывает проверки, необходимые для успешного сопоставления значения с образцом.
* вторая часть описывает захватываемые переменные, если сопоставление прошло успешно.

Формально образец может быть следующего вида:

<table>
<tr>
	<th>Образец</th>
	<th>Синтаксис</th>
	<th>Захват переменных</th>
	<th>Описание</th>
</tr>
<tr>
	<td>Литерал</td>
	<td><code>число</code>, <code>строка</code>, <code>true</code>, <code>false</code>, <code>[]</code></td>
	<td>Нет</td>
	<td>Используется простое сравнение значения или его части образцом.</td>
</tr>
<tr>
	<td>Заглушка</td>
	<td><code>_</code></td>
	<td>Нет</td>
	<td>Подходит любому значению и не захватывает никаких переменных. <br/>Чаще всего заглушка используется  в случаях, когда нам не важна какая-то часть сложного образца или когда хотим задать последнюю позицию в операторе <code>match</code>, соответствующую случаю "остальное".</td>
</tr>
<tr>
	<td>Идентификатор</td>
	<td><code>имя_переменной</code></td>
	<td><code>имя_переменной</code></td>
	<td>Начинается с маленькой буквы или подчёркивания. Проверки отсутствуют, захваченное значение сохраняется под именем <code>имя_переменной</code> и доступно в действиях.</td>
</tr>
<tr>
	<td>Кортеж</td>
	<td>(<code>обр<sub>1</sub></code>, <code>обр<sub>2</sub></code>, &hellip;, <code>обр<sub>N</sub></code>)</td>
	<td>Переменные из <code>обр<sub>i</sub></code></td>
	<td>Применяется к кортежам размера <code>N</code>, элементы которого проверяются соответствующими образцами.<br/>Совпадение считается успешным, если успешны все вложенные образцы.</td>
</tr>
<tr>
	<td>Запись</td>
	<td>{ поле<sub>1</sub>=<code>обр<sub>1</sub></code>, &hellip;, поле<sub>N</sub>=<code>обр<sub>N</sub></code> }</td>
	<td>Переменные из <code>обр<sub>i</sub></code></td>
	<td>Значение должно быть записью, содержащим перечисленные поля. Не перечисленные поля записи не проверяются и не захватываются.</td>
</tr>
<tr>
	<td>Список</td>
	<td><code>голова</code> :: <code>хвост</code></td>
	<td><code>голова</code>, <code>хвост</code></td>
	<td>Значение должно быть списком. Если список пуст, сопоставление неудачно, иначе <code>голова</code> проверяется на соответствие головному образцу, а <code>хвост</code> &ndash; хвостовому образцу.</td>
</tr>
<tr>
	<td>Захват</td>
	<td><code>образец as идентификатор</code></td>
	<td><code>идентификатор</code></td>
	<td>Сначала проверяется <code>образец</code>, если сопоставление прошло успешно, захваченная часть сохраняется под именем <code>идентификатор</code></td>
</tr>
<tr>
	<td>Условие</td>
	<td><code>образец when условие</code></td>
	<td>переменные из <code>образец</code></td>
	<td>Сначала проверяется <code>образец</code>. Если сравнение успешно, проверяется <code>условие</code> (переменные могут захватываться). Соответствие признаётся удачным, если выполняется <code>условие</code>.</td>
</tr>
<tr>
	<td>Вариант</td>
	<td><code>Имя(обр<sub>1</sub></code>, &hellip;, <code>обр<sub>N</sub>)</code></td>
	<td>Переменные из <code>обр<sub>i</sub></code></td>
	<td><code>Имя</code> начинается с заглавной буквы, количество образцов должно соответствовать количеству параметров конструктора варианта. В случае единственного параметра, если образец &ndash; <code>литерал</code>, <code>_</code> или <code>идентификатор</code>, круглые скобки можно опустить.</td>
</tr>
<tr>
	<td>Альтернатива</td>
	<td><code>обр<sub>1</sub> | обр<sub>2</sub> | </code> &hellip; <code>| обр<sub>N</sub></code></td>
	<td>нет</td>
	<td>Сопоставление успешно, если сопоставление хотя бы одиного из образцов прошло успешно.<br/>Текущая версия компилятора Ficus не разрешает захват переменных в альтернативных образцах.</td>
</tr>
</table>


### Примеры

* **Литерал**, **Заглушка**

```
val a = ...
match a {
  | 5 => println("пять")
  | _ => println("не пять")
}
```

* **Идентификатор**

```
val a = 1 :: 2 :: 3 :: []
  match a {
    | b => println(f"Список целиком: {b}")
  }
```

* **Кортеж**

```
val a = (1, 2, 3)
  match a {
    | (b, c, _) => println(f"Части кортежа: {b}, {c}")
  }
```

* **Запись**

```
type rect_t = { x: int; y: int; width: int; height: int }
val r = rect_t { x=10, y=5, width=30, height=60 }

match r {
  | { x = v } => println(f"Поле x записи равно {v}")
}
```
* **Список**

```
// Первый образец сработает для 
// val a = 1 :: 2 :: 3 :: []
val a = 1 :: []
match a {
  | h :: h1 :: t => println(f"Голова: {h}, второй элемент {h1}, хвост: {t}")
  | h :: t => println(f"Голова: {h}, хвост: {t}") 
  | []     => println("Пустой список")
}

```

* **Захват**

```
type pt = { x: int; y: int }

val l = pt {x = 10, y = 20 } :: []

match l {
    | {x = v} as h :: t => println(f"Значение поля x в голове списка: {v}, голова: {h}")
}
```
* **Условие**

```
type rect_t = { x: int; y: int; width: int; height: int }
val r = rect_t { x=10, y=5, width=30, height=60 }

match r {
  | { x = v } when v > 15 => println(f"Поле x записи равно {v}")
  | _ => println("Условие не сработало")
}
```

* **Вариант**, **Альтернатива**

```
type v = | A | B: int | C: (int, int)

val u = B(5)

match u {
  | A => println("Вариант A")
  | B v => println(f"Вариант B, значение {v}")
  | C(v, _) => println(f"Вариант C, значение {v}")
}
```

Приведённые описания позволяют составить представление о возможностях оператора `match`. Он способен заменить конструкцию `switch` в C и даёт гораздо больше возможностей. Посмотрим несколько примеров, демонстрирующих применение операторов для обработки списков:

```
fun list_rev_pm(l: 't list): 't list
{
    fun rev_(l_in: 't list, l_out: 't list): 't list =
        match l_in {
        | x :: rest => rev_(rest, (x :: l_out))
        | [] => l_out
        }
    rev_(l, [])
}

fun list_foldl_pm(f: ('t, 'res)->'res, res0: 'res, l: 't list): 'res =
    match l {
    | x :: rest => list_foldl_case(f, f(x, res0), rest)
    | _ => res0
    }
```

Предыдущая реализация для наглядности:

```
fun list_foldl(f: ('t, 'res)->'res, res0: 'res, l: 't list): 'res =
    if l.empty() {res0} else {list_foldl(f, f(l.hd(), res0), l.tl())}
```

Видим, что с помощью сопоставления с образцом и оператора `::` удалось избавиться от методов `empty()`, `hd()` и `tl()`!

Все, что нам требуется для обработки списков, это сопоставление с образцом и оператор `::`.

В самом деле, если вы посмотрите в исходный код модуля `List`, то увидите следующие (ну или очень похожие определения):

```
fun hd(l: 't list): 't =
    match l { | a :: rest => a | _ => throw NullListError }

fun tl(l: 't list): 't list =
    match l { | a :: rest => rest | _ => throw NullListError }

fun empty(l: 't list): bool =
    match l { | [] => true | _ => false }
```
И последнее замечание касается сортировки списков. Нам дан список элементов и функция поэлементного сравнения, нужно получить сортированный список.

Очевидно, что эта задача не решается с помощью хвостовой рекурсии, так как наилучший алгоритм сортировки работает за `O(N log N)`. Как решить эту задачу?

Возможны два подхода: 

* элементы списка перемещаются в массив, после чего применяется стандартный императивный алгоритм сортировки. Это ровно то, что сделано в текущей реализации, поскольку такой метод самый эффективный. 

* чисто функциональная сортировка слиянием с временной сложностью `O(N log N)`. Вот как это работает:

  - используется вспомогательная функция `merge`, сливающая два упорядоченных списка в один. Это простая функция с хвостовой рекурсией.
  - исходный список длиной `N` превращается в `N` отдельных списков, каждый из которых содержит один элемент.
  - выполняется `log⁡(N)` проходов по этому списку списков. На каждом проходе последовательно берутся два соседних списка и сливаются в один. Итоговая сложность прохода &ndash; `O(N)`, после каждого прохода длина списка уменьшается вдвое, а длина каждой последовательности удваивается. В конце мы получаем сортированный список.

Приведём полную реализацию алгоритма сортировки слиянием для списков:

```
/* 
  mergeSort: процедура сортировки методом слияния, работающая за O(N log N).
  Создаётся список списков, после чего эти списки сливаются до тех пор, 
  пока не останется один список.
*/
fun mergeSort(l: 't list, lt: ('t,'t)->bool): 't list =
    match l {
    | [] => []
    | l =>
        // Функция сливает два сортированых списка в один.
        // Используется сокращенный синтаксис функции для случая,
        // когда перебираются параметры функции сопоставляются 
        // с образцом.
        fun merge(_: 't list, _: 't list): 't list
        {
            | ((a :: at) as l, (b :: bt) as r) =>
                if lt(a, b) {
                  a :: merge(at, r)
                } else {
                  b :: merge(l, bt)
                }
            | (l, []) => l
            | ([], r) => r
        }

        // scan проходит по списку [:: l0, l1, l2, ... ] сортированых 
        // списков, сливает пары списков: l0 с l1, l2 с l3 и т.д.,
        // так что после этого прохода мы получаем (N+1)/2 списков вместо N.
        fun scan(_: 't list list): 't list list
        {
            | a :: b :: rest => merge(a, b) :: scan(rest)
            | l => l
        }

        // Повторятся сканирование, пока не останется ровно один список.
        fun loop(_: 't list list): 't list
        {
            | a :: [] => a
            | l => loop(scan(l))
        }

        // Начинаем со списка одноэлементных списков
        loop([:: for a <- l { [:: a] }])
    }


val a = 3 :: 4 :: 5 :: 6 :: 2 :: 1 :: []

@inline fun less(a: int, b: int): bool = a < b

println(mergeSort(a, less))
```

Замечания по реализации:

* внутри действия оператора `match` можно разместить большое количество дополнительного кода. Здесь показано создание трёх вложенных функций, помогающих структурировать решение и облегчить чтение кода.
* если тело функции сводится к оператору `match`, принимающему все параметры функции, то можно сократить написание и исключить явное использование ключевого слова `match`.

```
fun foo(args) {
  | <cases>
}
```

вместо

```
fun foo(args) =
match args {
  | <cases>
}
```

* в функциональных программах, особенно при обработке символических данных, операторы `match` и рекурсия тесно связаны.
* ранее рекомендовалось использовать хвостовую рекурсию. В данной реализации функции `merge` и `scan` не используют хвостовую рекурсию, так как аналогичные функции с хвостовой рекурсией порождают обращённые списки, а многократное обращение нежелательно (растет потребление ресурсов). Здесь предпочтение отдаётся избыточному созданию узлов списка взамен увеличения потребления пространства стека.

## Образцы для захвата

Фактически оператор `match` &ndash; не единственное место, где применяется сопоставление с образцом. Ранее уже встречались ограниченные формы образцов, используемые в других частях кода. Ограниченность здесь подразумевает отсутствие проверок, иными словами, такие образцы служат только для захвата значений. Ниже приведены примеры: 

```
// распаковываем кватернион с помощью сопоставления с образцом
val (x, y, z, _) = q

// ошибка: левая сторона определения значения должна быть образцом и не 
// содержать литералы
val (1., y, z, _) = q

// захватываем границы рамки и статус отслеживания объекта
val { box, tracked } = obj

// ошибка: левая сторона определения значения должна быть образцом и не 
// содержать литералы
val { label=("car", _), box, tracked=true } = obj

// распаковываем пиксели при переборе изображения
val gray = [for (r, g, b) <- img {
        sat_uint8(round(r*0.299 + g*0.587 + b*0.114))
}]

// перспективная проекция трёхмерной точки на плоскость
fun normalize((x, y, z): (float*3)) = (x/z, y/z)
```

Образцы для захвата можно использовать в следующих случаях:

* формальные параметры функций
* левая часть определения значений и переменных
* переменные цикла.
