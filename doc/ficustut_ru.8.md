Суммарные типы или варианты

В разделе Списки мы упомянули, что односвязные неизменяемые списки использовались в оригинальной версии Lisp для представления любых данных, будь то структуры данных или программы. Например, выражение a*b + c в Lisp представлено так: (+ (* a b) c). Иначе говоря, на верхнем уровне у нас имеется список из трёх элементов, первым элементом которого является операция +, вторым — вложенное выражение (* a b), третьим — символ c. Такое представление легко выразить в Lisp (или Python), поскольку в этих языках списки гетерогенны. Теперь попробуем воспроизвести подобное в Ficus, используя известные нам типы данных. Быстро выясняется, что попытка терпит неудачу, так как все элементы списка должны принадлежать одному типу, что неверно в нашем случае. Ещё сложнее оказывается представлять иерархические структуры данных с помощью списков, кортежей, массивов или записей, ведь такие структуры по определению рекурсивны, а изученные нами ранее структуры не поддерживают рекурсию.

Однако существует элегантное и мощное решение проблемы, впервые предложенное языком программирования ML. Называется оно суммарными типами. Почему оно носит название "суммарный тип"? Дело в теории множеств. Пусть имеются несколько типов: T1, T2, ..., Tn. Каждый тип определяет множество возможных значений, которые могут принимать экземпляры этого типа. Определим теперь кортеж:

type T = (T1, T2, ..., Tn)

Тогда множество значений, которые может принять экземпляр кортежа, будет являться декартовым произведением множеств, определённых типами T1, T2, ..., Tn. Отсюда и принятая в Standard ML и OCaml нотация для кортежей:

(* Определение кортежа в SML/OCaml *)
type T = T1 * T2 * ... * Tn

Но как определить тип, множество значений которого являлось бы объединением, или суммой, множества значений типов T1, ..., Tn? Или, иными словами, мы хотели бы нечто вроде T1 + T2 + ... + Tn. Если удастся определить подобный тип, мы сможем создать разновидность гетерогенных списков, где каждый элемент может быть одного из типов T1, ..., Tn. Попробуем представить такой "суммарный тип" с помощью записи:

val T1_tag = 1
val T2_tag = 2
...
val Tn_tag = n

type псевдо_суммарный_T =
{
    tag: int
    T1_val: T1
    T2_val: T2
    ...
    Tn_val: Tn
}

Такая конструкция неэффективна по двум причинам:

    Она крайне расточительна по памяти, так как одновременно используется только одно из полей Tj_val.
    Конструкция небезопасна, так как можно полагать, что знаем метку, пропустить проверку и обратиться к какому-то полю Tj_val, хотя реальная метка может отличаться, делая данное поле нерелевантным.

Если бы в Ficus существовал реальный "объединённый" тип, аналогичный типу в C, это решило бы проблему с памятью, но сделало бы язык опасным. Вместо этого в Ficus предусмотрен безопасный функциональный объединённый тип, известный как суммарный тип, алгебраический тип или вариант. Будем чаще употреблять термин вариант.

Вариант определяется следующим образом:

type optional_type_parameters type_name =
    // первая вертикальная черта после знака "=" необязательна
    | Tag1 [: T1]
    | Tag2 [: T2]
    ...

где Tagj — идентификатор, начинающийся с прописной буквы, а Tj — некий тип. Если тип не указан, подразумевается, что он равен void, то есть метка сама по себе полностью определяет соответствующее ей значение и не нуждается в атрибутах. В простейшем варианте вариант может выступать в роли перечисления:

type month = Jan | Feb | Mar | Apr | May | Jun | Jul
            | Aug | Sep | Oct | Nov | Dec

Однако настоящая сила вариантов раскрывается, когда мы вводим типы для меток. Вот абстрактный синтаксис для подобия Lisp-микроязыка:

type unop = Neg | Head | Tail | Null
type binop = Add | Sub | Mul | Div | Mod | Cons
            | CmpEQ | CmpLT | CmpLE | CmpNE | And | Or
type expr =
        | Num: double
        | Char: char
        | Nil | Void
        | Bool: bool
        | Val: string
        | Binary: (binop, expr, expr)
        | Unary: (unop, expr)
        | Call: (expr, expr list)
        | DefVal: (string, expr)
        | DefFun: (string, string list, expr)
        | If: (expr, expr, expr)
        | Seq: expr list

Заметим, что тип expr рекурсивно ссылается на самого себя в некоторых вариантах. Это значит, что варианты способны представлять рекурсивные структуры данных!

Посмотрим, как определить факториал в этом микроязыке:

val n = Val("n")
val one = Num(1.0)
val f = DefFun("fact", "n" :: [], If(Binary(CmpLE, n, one), one,
            Binary(Mul, n, Call(Val("fact"), Binary(Sub, n, one) :: []))))

Создание экземпляров вариантов в Ficus облегчено благодаря следующему механизму:

    Метки с параметрами (такие как DefFun) выступают в роли конструкторов, принимающих соответствующие аргументы и возвращающих экземпляр с нужной меткой.
    Метки без параметров (например, CmpLE) могут использоваться непосредственно как значения. Они также являются конструкторами, просто записанными в виде значений, а не функций (следовательно, используется CmpLE, а не CmpLE()).

Итак, создав экземпляр варианта, мы можем попытаться каким-то образом его обработать. Тогда как для других функциональных типов (кортежи, списки) существуют специальные методы доступа (. для записей, List.hd и List.tl для списков), для вариантов доступна единственная возможность — сопоставление с образцом. Давайте реализуем часть интерпретатора нашего мини-Lisp языка:

type entry_type = ValEntry: (string, expr) | FunEntry: (string, expr)
type env_t = entry_type list
fun eval(e: expr, env: env_t): (expr, env_t) =
match e {
| Binary(bop, e1, e2) =>
    val e1_ = eval(e1, env)
    val e2_ = eval(e2, env)

    // данная техника часто используется в сопоставлении с образцом;
    // мы формируем кортеж из нескольких значений и
    // затем используем ниже кортежные шаблоны.
    // то есть,
    //    match (expr1, expr2, ..., exprN) {
    //    | ...
    //    | (pat1, pat2, ..., patN) => ...
    //    | ...
    //    }
    // эмулирует что-то вроде следующего:
    //     ... else if expr1 matches pat1 &&
    //              expr2 matches pat2 && ...
    //              exprN matches patN { ... }
    //
    (match (bop, e1_, e2_) {
    | (Sub, Num(n1), Num(n2)) => Num(n1 - n2)
        ...
    | (CmpLE, Num(n1), Num(n2)) => Bool(n1 <= n2)
        ...
    }, env)
| DefVal(v, e) =>
    val e_ = eval(e, env)
    // добавляем пару (v, e) в среду
    (Void, ValEntry(v, e_) :: env)
| Call(e, args) =>
    // вычисляем e и args
    // находим функцию в среде,
    // затем добавляем пары (формальный аргумент, фактическое значение)
    // в среду и оцениваем тело
    ...
...
}

Использование вариантов совместно с оператором match решает обе проблемы наивной реализации объединений:

    Безопасность обеспечивается тем, что сравнение метки и выбор нужных данных происходят одновременно, исключая возможность доступа к неправильным данным.
    Эффективность достигается за счёт внутреннего представления вариантов в виде объединений с метками на уровне C.
    Удобство работы с такими типами трудно переоценить.

Примечание: соглашение о наименовании меток

Примеры сопоставления с образцом демонстрируют важность соглашения о наименованиях меток. Согласно соглашению, метки начинаются с заглавной буквы, а захватываемые переменные — с малой. Без подобного соглашения возможна путаница, особенно при случайных опечатках. Например:

...
match (bop, e1, e2) {
| (Sub, ...) => ...
// CmpLE ошибочно набрано как CmpLe и могло бы быть воспринято как
// захваченная переменная без указанного соглашения.
// Но поскольку "CmpLe" начинается с заглавной буквы,
// компилятор выдаст ошибку о неизвестной метке "CmpLe"
| (CmpLe, ...) => ...
...
}

Рассмотрим ещё один пример, связанный с деревьями, на сей раз речь пойдёт о красно-чёрных деревьях.

Красно-чёрное дерево (Red-Black Tree) — это представление бинарного дерева поиска, позволяющее хранить данные, доступные по ключу за время O(log N) (при условии, что дерево хранит N элементов). Время вставки и удаления также составляет O(log N). Пример дерева, хранящего несколько целых чисел, изображён на рисунке:

Рисунок 1. Красно-чёрное дерево.

Мы можем описать подобное дерево следующим образом:

type color = Red | Black
type rbtree = Empty | RBNode: (int, color, rbtree, rbtree)
// создадим дерево из трёх целых чисел
val t3 = RBNode(5, Black, RBNode(1, Red, Empty, Empty),
                RBNode(10, Red, Empty, Empty))

Определение весьма напоминает абстрактное синтаксическое дерево из предыдущего примера. Реализуем простую функцию для вычисления глубины дерева:

fun depth(t: rbtree)
{
    match t {
    | Empty => 0
    | RBNode(_, _, left, right) => 1+max(depth(left), depth(right))
    }
}

Логика предельно проста и действительно похожа на псевдокод: если переданное дерево пустое, глубина равна нулю, иначе мы игнорируем цвет узла и его значение, выбираем левую и правую ветви, рекурсивно вычисляем глубину обеих подветвей и возвращаем результат 1 + max(глубина левой подветви, глубина правой подветви).

Функции вставки и удаления элементов в красно-чёрное дерево здесь не показаны, они реализованы в стандартной библиотеке, смотрите модули Set и Map для деталей. Вместо этого перейдём к примеру реализации обобщённых структур данных.
Обобщённые варианты

Ранее мы убедились, насколько легко реализовать обобщённые функции обработки списков, просто записывая 't list. Что произойдёт, если захотим применить обобщённую версию типа 't rbtree? Всё окажется точно так же:

type color = Red | Black
type 't rbtree = Empty | RBNode: ('t, color, 't rbtree, 't rbtree)
// создадим дерево из трёх строк
val t3 = RBNode("b", Black, RBNode("a", Red, Empty, Empty),
                RBNode("c", Red, Empty, Empty))

Нам даже не понадобится явно инстанцировать структуру красно-чёрного дерева для строк. Конструкторы вариантов становятся обобщёнными функциями и автоматически создают экземпляр нужного типа. Единственная тонкость связана с обработкой пустого дерева — какой тип оно должно вернуть? Например, int rbtree, string rbtree или какой-то иной тип? Обычно компилятор автоматически определяет нужный тип исходя из контекста, но иногда потребуется явно указать его, например:

val empty_int_rtbtree = (Empty : int rbtree)

Насколько изменится обработка деревьев? Практически никак:

fun depth(t: 't rbtree)
{
    match t {
    | Empty => 0
    | RBNode(_, _, left, right) => 1+max(depth(left), depth(right))
    }
}

Варианты с реквизитами-записями

Иногда некоторым случаям варианта требуются сложные реквизиты, поэтому разумно использовать записи в качестве атрибутов. Синтаксис напрямую поддерживает подобные случаи. Рассмотрим вариацию определения красно-чёрного дерева с применением записей:

type 't rbtree =
    | Empty
    | RBNode: { value: 't; clr: color;
                left: 't rbtree; right: 't rbtree }
val t3 = RBNode {
    value="b", clr=Black,
    left=RBNode { value="a", clr=Red, left=Empty, right=Empty },
    right=RBNode { value="c", clr=Red, left=Empty, right=Empty }
    }
fun depth(t: 't rbtree)
{
    match t {
    | Empty => 0
    // имя метки обязательно,
    // в отличие от самостоятельно определённых записей
    | RBNode {left=l, right=r} => 1+max(depth(l), depth(r))
    }
}

Записи можно прямо встраивать в определения вариантов, нет нужды предварительно определять их отдельно (хотя иногда это бывает полезным, например, чтобы отвлечь атрибуты от метки и передать их дальше). Подобная нотация немного увеличивает объём текста по сравнению с кортежами, но код остаётся читаемым.
Однослучайные варианты

Рассмотренный выше вариант является частным случаем, который на первый взгляд кажется бесполезным. Тем не менее он может оказаться полезен. Допустим, мы хотим определить тип рациональных чисел и перегрузить для него операции (+, - и т.п.). Попытавшись определить тип и операции следующим образом:

type ratio_t = (int, int)
operator + ((n1, d1): ratio_t, (n2, d2): ratio_t) = ...

мы столкнёмся с проблемой конфликта с общим определением оператора + для кортежей из двух элементов в модуле Builtins, так как в таком случае ratio_t не является новым типом, а лишь псевдонимом кортежа из двух целых чисел. Проблема решается изменением определения на однослучайный вариант:

type ratio_t = Ratio: (int, int)
operator + (r1: ratio_t, r2: ratio_t)
{
    val Ratio(n1, d1) = r1
    val Ratio(n2, d2) = r2
    val n = n1*d2 + n2*d1, d = d1*d2
    val k = GCD(n, d)
    Ratio(n/k, d/k)
}
// так как у нас появился отдельный тип,
// мы можем определить для него специальную функцию string()
fun string(r: ratio_t) {
    val Ratio (n, d) = r
    f"{n}/{d}"
}
// теперь код стал удобнее читать, хотя и немного увеличился в объёме
println(Ratio(1, 100) + Ratio(3, 50))

Однослучайные варианты позволяют превращать анонимные структуры в именованные, наделяя их возможностью иметь собственные наборы перегружаемых операций и функций.
Тип Option

Мы уже рассматривали тип option раньше. Повторимся, что этот тип фактически не встроен в язык, а определяется в модуле Builtins.fx следующим образом:

class 't option = None | Some: t

Кроме того, компилятор Ficus распознаёт сокращённую нотацию 't? наряду с традиционной формой 't option. Однако обратите внимание, что один из фундаментальных типов Ficus, на самом деле, является вариантом. Покажем его полезность снова на примере реализации функции поиска в красно-чёрном дереве, предположив, что узлы содержат пары (ключ, данные) и мы ищем данные, ассоциированные с заданным ключом:

fun find_opt(t: ('key, 'data) rbtree, k0: 'key): 'data? =
match t {
| Empty => None
| RBNode((k, data), _, left, right) =>
    if k0 == k {Some(data)}
    else if k0 < k {find(left, k0)}
    else {find(right, k0)}
}

Применение типа option как возвращаемого значения функции устраняет необходимость использования магического значения или отдельного флага для обозначения отсутствия ключа:

val names = [:: "Bob", "Alice", "Sam"]
for name <- names {
    match find_opt(phone_book, name) {
    | Some(number) => println(f"{name}'s phone: {number}")
    | _ => println(f"{name} is not found in the phonebook")
    }
}

Исключение

Исключения — удобный, безопасный и эффективный механизм обработки ошибок, а также контроля потока выполнения. В Ficus легко определить новое исключение, возбудить его и обработать.

Новое исключение задаётся единственной строкой кода:

exception NameIsTakenError [ : optional_type_spec ]

NameIsTakenError — это идентификатор, начинающийся с заглавной буквы. Синтаксис аналогичен определению очередного случая варианта, а внутренне исключения являются специальными случаями открытого встроенного типа "exn". Определение исключения — это, по сути, задание конструктора NameIsTakenError(), который будет применяться для создания конкретного исключения.

Возбудить исключение можно оператором throw:

throw expr

где expr — выражение типа exn. Отметим, что само по себе создание исключения не приводит к его возбуждению. Обычно throw применяют сразу после создания исключения:

fun foo()
{
    ...
    throw Fail("что-то пошло не так в функции foo")
    ...
}

fun access_my_container(c: container_t, i: int)
{
    val n = size(c)
    if i < 0 || i >= n {throw OutOfRangeError}
    ...
}

Обработка исключений также проста и выполняется с помощью сопоставления с образцом, но не оператора match, а специального оператора try-catch:

try
    expr_or_code_block
catch {
| exn_pattern1 => expr_seq1
| exn_pattern2 => expr_seq2
...
| exn_patternM => expr_seqM
}

Дополнительно или вместо блока catch можно использовать блок finally, выполняемый после завершения блока try и действий блока catch, вне зависимости от наличия исключений.

Вот пример устойчивого кода:

import File
val file_size =
    try {
        val f = File.open("log.txt", "rt")
        var fsz = -1i64
        try {
           f.seek(0, File.SEEK_END)
           fsz = f.tell()
        } finally {
           f.close()
        }
        fsz
    }
    catch {
    | FileOpenError =>
        println("ошибка: файл журнала не открывается")
        -1i64
    }

В данном примере мы использовали try-catch для обработки случая невозможности открытия файла. Дополнительно применялся внутренний блок try-finally, гарантирующий закрытие файла независимо от возникновения исключений.

Что случится, если брошенное исключение не подойдёт ни к одному из шаблонов? Оно продолжит подниматься вверх по стеку вызовов, словно каждый блок catch содержал следующее:

catch {
<patterns ... handlers>
| e => throw e // если есть блок finally,
               // он выполнится немедленно после throw,
               // затем исключение продолжит распространение
}

Мы отмечали вначале, что исключения могут служить механизмом управления потоком выполнения. Например, следующая конструкция имитирует мощный оператор выхода из цикла break:

fun isint(str: string): bool
{
    // ещё одна версия цикла, проверяющего,
    // представляет ли строка целое число
    try {
        for c <- str {
            val digit = ord(c) - ord(#"0")
            if digit < 0 || digit > 9 {
                // Break — стандартное исключение
                throw Break
            }
        }
        true
    }
    catch { | Break => false }
}

Важно понимать, что исключение Break или любое другое может быть перехвачено на уровнях, удалённых от точки возбуждения, что делает данную эмуляцию намного мощнее обычного оператора break в C.
Исключения в сгенерированном коде

Так как компилятор Ficus генерирует код на C по умолчанию, исключения языка C++ не используются в результате компиляции. Не применяются и длинные переходы (long jump), популярное средство замены исключений в C. Вместо этого компилятор задействует коды возврата и проводит проверки после каждого вызова функции. Данный подход оказался эффективным решением.