Выход из функции с помощью return

Ficus поддерживает оператор return, характерный для императивных языков, позволяющий завершить выполнение функции раньше с возможностью возвращения значения. Подобно прочим управляющим операторам в Ficus, return является выражением. Вся конструкция return имеет тип void, независимо от того, возвращает ли она значение или нет.

fun foo(arg1: t1, ..., argn: tn) {
    ...
    if some_expr { return some_value }
    ...
    match another_expr {
    ...
    | pattern => return another_value
    ... // остальные действия должны иметь тип void
    }
    final_ret_value // финальное выражение
}

В данном примере значения some_value, another_value и final_ret_value обязаны иметь одинаковый тип. Если функция имеет тип void, то все операторы return в ней должны использоваться без возвращения значения.
Числа

Набор числовых типов и операций с ними в Ficus близок к таким языкам, как C/C++ и большинству других популярных языков программирования.

Главное отличие от C/C++ и Python касается типа int. В C/C++ тип int чаще всего представляет собой 32-битное целое число, даже на 64-битных архитектурах. В Python начиная с версии 3.x тип int реализует целые числа произвольной точности. В Ficus тип int на 32-битных архитектурах является 32-битным числом, а на 64-битных — 64-битным. Важно отметить, что в Ficus отсутствует тип uint или unsigned.

Преобразования между различными числовыми типами не происходят неявно. Например, если функция принимает аргумент типа int, а у вас есть значение типа uint8, его нужно явно привести к типу int. Существует несколько способов преобразования числа из одного типа в другой:

    С помощью оператора приведения типа (expr :> целевой_тип):

val a = 34587345
val b = 987654321
val product = (a :> uint64) * b

(Оператор :> универсален и может использоваться для преобразования чисел в строки, запросов интерфейсов класса и т.п.; подробности см. в разделе Объектно-ориентированное программирование.)
С помощью специализированной функции преобразования: целевое_имя_типа() или sat_целевое_имя_типа(), например, int8() преобразует число в тип int8. Ранее мы встречались с функцией string(), которая преобразует различные значения в строку. Функции вида sat_[u]intN() осуществляют преобразование с насыщением, то есть обрезают аргумент вместо простого отбрасывания младших бит:

// псевдо-реализация sat_uint8()
fun sat_uint8(x: int) =
    if x < 0 {0u8} else if x > 255 {255u8} else {uint8(x)}

    Преобразование вещественного числа в целое — специальный случай, для которого предназначены несколько функций:
        round() — округление к ближайшему целому
        floor() — округление к минус бесконечности
        ceil() — округление к плюс бесконечности
        trunc() — округление к нулю, аналогично C.

Стандартный набор арифметических, побитовых и сравнительных операторов в Ficus аналогичен большинству других языков. Частичный перечень доступных операций см. в разделе Выражения.

Аргументы бинарных операций могут принадлежать различным типам, в таких случаях применяются правила повышения типов, то есть оба аргумента приводятся к единому, достаточно широкому типу:

    Прежде чем повышение произойдёт, если тип T1 или T2 — это int8, uint8, int16 или uint16, он приводится к типу int.
    Если после предварительной подготовки оба типа совпадают, результатом повышения будет именно этот общий тип.
    Иначе, если один из типов — целое число, а другой — вещественное, результатом будет вещественный тип.
    Если один из типов — int или int32, а другой — int64, результатом будет int64.
    Если один из типов — uint32, а другой — int64 или uint64, результатом будет int64 или uint64.
    Если один из типов — float, а другой — double, результатом будет double.
    В противном случае компилятор выдаёт ошибку, и нужно явно привести аргументы к подходящей паре типов.

Эти правила применяются рекурсивно для массивов и кортежей при операциях .+, .-, .*, ./, обрабатываемых поэлементно.

Кроме того, в Ficus имеются полезные функции, работающие с числами:

    min(a, b), max(a, b) — ищут минимальное/максимальное значение среди двух чисел
    abs(x) — вычисляет абсолютное значение аргумента
    sign(x) — вычисляет знак аргумента (-1, 0 или 1)
    sqr(x) — возводит аргумент в квадрат, то есть x*x
    sqrt(x) — извлекает квадратный корень
    sin(x), cos(x), exp(x), log(x), atan2(y, x) и другие стандартные математические функции из модуля Math, автоматически подключаемого.

Кортежи и записи
Кортежи

Кортеж — это упорядоченная коллекция фиксированного размера, в которой элементы известны на этапе компиляции. Размеры кортежа и типы его элементов определяются заранее. Кортежи могут содержать элементы любых типов, включая сами кортежи, и могут быть вложены в другие типы:

type quaternion = (float, float, float, float) // или (float*4)
type color_t = (uint8*3) // сокращение для (uint8, uint8, uint8)
type label_t = (string, color_t)
type graph_t = (int, int list) list

Создание кортежа выполняется путем помещения двух или более элементов, разделённых запятыми, в круглые скобки:

val q: quaternion = (1.f, 0.f, 0.f, 0.f)
// явно указали тип, но это не обязательно
val magenta : color_t = (255u8, 0, 255u8)
// другое указание типа кортежа
val yellow : (uint8*3) = (255u8, 255u8, 128u8)
val label = ("car", magenta)

Кортежи могут использоваться анонимно, без явного указания типа. Однако можно задать удобные синонимы, как показано выше.

Обращение к элементам кортежа осуществляется с помощью нотации tuple_expr.целочисленный_литерал. Или можно распаковать кортеж:

val (q_re, qi, qj, qk) = q
val (r, g, b) = magenta

val channel_idx = 1
// правильный способ извлечь элемент кортежа
fun channel(c: color, idx: int) =
   if idx == 0 {c.0}
   else if idx == 1 {c.1}
   else if idx == 2 {c.2}
   else {throw OutOfRangeError}

val label_name = label.0
val label_color = label.1
val i = i1.0

Кортежи как короткие числовые векторы

В Ficus нет специализированных типов для коротких числовых векторов, точек, комплексных чисел, кватернионов, пикселей RGB и прочих подобных сущностей. Вместо этого предлагается использовать кортежи. Например, кортеж типа (uint8, uint8, uint8) занимает 3 байта и настолько же эффективен, как встроенный тип пикселя RGB, будь он доступен.

Для удобства работы с такими типами в стандартной библиотеке Ficus определены базовые операции над подобными кортежами, в частности:

    арифметические операции:
        поэлементные: .+, .-, .*, ./
        произведение комплексных чисел для 2-компонентных кортежей: *
        произведение кватернионов для 4-компонентных кортежей: *
    операции сравнения: лексикографический порядок кортежей
    нормировка: вычисляет корень суммы квадратов элементов кортежа
    скалярное произведение: dot()
    векторное произведение для 3-компонентных кортежей: cross()
    печать и преобразование в строку: print(), string()
    и другие операции, полный список см. в Builtins.fx.

Вложенные кортежи

Кортежи могут содержать произвольные элементы, включая другие кортежи. Доступ к элементам вложенных кортежей осуществляется подобным образом:

fun transform(Rt: ((double*3)*2), pt: (double*2)) =
    (Rt.0.0*pt.0 + Rt.0.1*pt.1 + Rt.0.2,
     Rt.1.0*pt.0 + Rt.1.1*pt.1 + Rt.1.2)
val a = 30*M_PI/180
val Rt = ((cos(a), -sin(a), 10.), (sin(a), cos(a), 0.))
val pt1 = (1., 0.)
println(transform(Rt, pt1))

Хотя визуально кажется, что дробные числа "парят" после кортежей, парсер корректно интерпретирует эту конструкцию.

Данный пример показывает, что кортежи могут представлять не только векторы, но и маленькие матрицы.
Изменение кортежей

Ранее мы рассмотрели способы создания и чтения кортежей. Теперь перейдем к изменению кортежей. Сами по себе кортежи — неизменяемые структуры данных, и прямое изменение их элементов невозможно. Однако, если кортеж хранится в переменной (var), вы можете присвоить ему новый кортеж:

var vec = (1.f, 0.f, 0.f)
// "Изменим" второй элемент, создав новый кортеж
vec = (vec.0, vec.1 + 0.1f, vec.2)

Так как прямой заменой это неэффективно, компилятор разрешает изменять отдельные элементы, создавая иллюзию полной замены кортежа новым:

var vec = (1.f, 0.f, 0.f)
// изменим только второй элемент
vec.1 += 0.1f

Это не нарушает принцип "неизменяемости кортежей", а скорее служит оптимизацией с удобным синтаксисом.

Данная оптимизация и удобный синтаксис применимы ко всем случаям, когда кортеж хранится в изменяемом расположении:

    в переменной
    в элементе массива
    в ссылаемой величине (см. раздел Ссылки)

Записи

Запись похожа на кортеж, но её элементы (называемые полями) имеют имена и обращаются по имени. Записи не могут быть анонимными, они должны быть явно определены.

Записи создаются с помощью нотации { имя1=значение1, ..., имяN=значениеN }, а доступ к полям осуществляется через конструкцию expr.имя_поля. Записи также могут быть распакованы:

type rect_t = {x: int; y: int; width: int; height: int}
val r = rect { x=10, y=5, width=30, height=60 }
val r_area = r.width*r.height

type object_t // '=' можно пропустить перед '{'
{
    box: rect_t // разделяйте поля символом ';' или переходом на новую строку
    velocity: (int, int)
    id: int=-1 // некоторым полям записей можно задать значения по умолчанию
    label=(string, (uint8*3))
    tracked: bool=true
}

// Порядок полей может быть произвольным при создании записи
val obj = object_t {
  box=r, id=5, velocity=(0, 0),
  label=("", (255u8, 255u8, 255u8))
  // используем значение по умолчанию для поля "tracked"
}
// Игнорируем метку и флаг отслеживания,
// считывая только рамку и скорость
// Сокращение "id" вместо "id=id"
val { box=r, id, velocity=(vx, vy) } = obj

Заметим, что при создании записи необходимо явно указать имя типа, так как это позволяет компилятору точно определить, какую запись мы имеем в виду, какие поля она содержит и какая последовательность полей используется.

При распаковке записи компилятор уже знает тип распаковываемого значения, поэтому тип записи опускается.
Изменение/обновление записи

Хотя кортежи обычно невелики и редко требуют частичного изменения, для записей это утверждение неверно, и изменение отдельных полей может требовать больших усилий, особенно если изменяется только одно поле. Для облегчения этой задачи в Ficus введен удобный оператор обновления записей .{}:

type Rect = {x: int; y: int; width: int; height: int}
val r0 = Rect {x=0, y=0, width=100, height=50}
val r1 = r0.{x = r0.x + 10} // r1 совпадает с r0, за исключением изменённой координаты x
type object_t = {
    id: int=-1;
    box: rect_t;
    velocity: (int, int)
}
val obj = object_t {box=r1, velocity=(10, 5)}
// здесь обновление записи распространяется на вложенные записи
var moved_obj = obj.{
    box = obj.box.{
       x = obj.box.x + obj.velocity.0,
       y = obj.box.y + obj.velocity.1
       }
    }
// запись rec .= {обновляемые_элементы} — это сокращение для
// rec = rec . {обновляемые_элементы}
moved_obj .= {velocity=moved_obj.velocity/2}

Отдельные элементы записи также могут быть изменены в тех же ситуациях, что и кортежи:

    если запись хранится в переменной
    если запись расположена в массиве записей
    если имеется ссылка на запись

Можно считать это своего рода оптимизацией.
Работа с записью (и кортежем), хранящимися по ссылке

Если у нас есть ссылка на кортеж или запись, мы можем сначала разыменовать ссылку и затем применить оператор . для доступа или изменения структуры (включая оператор обновления записи):

val r = ref (Rect {x=1, y=1, width=10, height=10})
println((*r).width*(*r).height)

Имеется удобная альтернатива, аналогичная C/C++:

...
println(r->width*r->height)
*r = r->{x = r->x + 5, y = r->y + 5}
r->x -= 5
r->y -= 5

Конструкция rec->что-то эквивалентна (*rec).что-то во всех случаях, и аналогично для кортежей.
Изменяемые поля записи

Представим, что запись представляет собой сложную структуру данных, например, трекер объектов, содержащий множество членов. Одни из них могут быть постоянными параметрами алгоритма, другие могут изменяться периодически, третьи отражают текущее состояние трекера, постоянно изменяющееся.

Такая запись может храниться в переменной (var), что позволяет обновлять её. Однако, если вы хотите реализовать функцию, обновляющую трекер (например, саму процедуру трекинга), сама функция не сможет изменить параметры записи, так как параметры функций неизменяемы. Она может лишь создать свежую обновленную структуру и вернуть её. Это чистый функциональный стиль, но слегка неэффективный и громоздкий.

Одним из решений может быть размещение записи в виде ссылки, что облегчит обновление. Тогда даже неизменяемые поля смогут быть изменены, а код станет немного объемнее из-за необходимости использовать оператор -> вместо ..

Частичным решением может стать объявление некоторых полей записи как изменяемых с помощью спецификатора var, например:

type Tracker =
{
    // некоторые параметры алгоритма
    eps: double
    search_radius: int = 20
    // текущее состояние
    var objs: object_t []
}

fun track(tracker: Tracker, detector: Detector, image: uint8 [,])
{
    ...
    for obj@i <- tracker.objs {
    // обновляем местоположение i-го объекта
        ...
    }
    if size(newly_tracked_obj) != 0 {
        // конкатенируем два массива;
        // подробности см. в разделе 'Массивы'
        tracker.objs = [\tracker.obj, \newly_detected_objs]
    }
}

Важно отметить, что запись с хотя бы одним изменяемым полем всегда размещается в куче, что влечет дополнительные издержки при изменении полей. Однако стоимость ниже, чем превращение нескольких полей записи в ссылки для возможности их изменения. Можете представить запись с изменяемыми полями как ссылку на запись, где поля без спецификатора var защищены от изменения. Или думайте о ссылке как о записи с единственным изменяемым полем (так сделано в OCaml). Подробности см. в разделе Ссылки.
Массивы

Ficus разрабатывался специально для численной обработки, поэтому в нём обеспечивается качественная поддержка многомерных массивов.

Многомерный плотный массив — встроенный тип в Ficus, обозначаемый как 't [,...], где количество запятых соответствует размерности массива минус единица. Многомерные массивы хранятся в памяти подряд в порядке строк (аналогично C/C++ и в отличие от Fortran и MATLAB, где используется порядок столбцов), и они не являются массивами массивов.

Массивы всегда требуют явной инициализации, как и другие типы в Ficus. Далее приведены возможные способы создания и инициализации массивов:

// Создадим массив 480x640 восьмибитных чисел,
// пригодный для представления серого изображения.
// Инициализируем элементы нулями.
val image = array((480, 640), 0u8)

// Построим другое изображение, выполнив арифметическую операцию
val lighter_image = image .+ 100u8

val phi = M_PI/3
val (a, b) = (cos(phi), sin(phi))
// Создадим матрицу поворота 2x2, явно указав все её элементы
val R = [a, -b; b, a]
val RR = R*R // произведём умножение матриц
val shift = (100., 10.)
// Составим аффинную матрицу 2x3:
// левый блок 2x2 будет инициализирован R,
// правый блок 2x1 — смещающим вектором
val affine = [\R, $$shift.0; shift.1]]

// используя comprehension
val gradient = [for y <- 0:256 for x <- 0:256
                  { sat_uint8((x, y, (x+y)/2)) }]

Создав массивы, мы можем легко читать и изменять их:

fun sumpixels(img: uint8 [,]): int =
    // Итерация по массиву с помощью цикла for
    fold sum=0 for x <- img {sum + x}

// Выделим интересующую область (ROI);
// данные не копируются, а совместно используются
val roi = image[50:100, 300:400]
// Подсчитаем сумму пикселов в ROI
val sum_roi = sumpixels(roi)

// Изменим ROI; родительское изображение изменится тоже
val (m, n) = size(roi)
for y <- 0:m
  for x <- 0:n {
     roi[y, x] ^= 255u8
  }

Заметим, что элементы roi могут быть изменены, даже если сам roi является значением. Это связано с тем, что массивы — изменяемые структуры.
Массивы индексируются с помощью нотации arr[idx_or_range1, idx_or_range2, ...], где каждый idx_or_rangej — это либо целое число (индекс), либо диапазон [start]:[end]:[step], где любой из компонентов start, end или step может отсутствовать, либо эллипсис :, означающий "взять все элементы вдоль этой оси (всё поле, весь столбец и т.д.)":

// создадим ненормализованную матрицу Адамара
fun Hadamard(n: int, one: 't): 't [,] {
    assert(n & (n-1) == 0)
    if n == 1 { [for i <- 0:1 for j <- 0:1 {one}] }
    else { val h = Hadamard(n/2, one); [\h, \h; \h, $-h)] }
}

val mtx = Hadamard(8, 1.)

// возьмём пятую строку матрицы, умножим все элементы на 2
// и прибавим полученный продукт к первой строке той же матрицы
mtx[1, :] += mtx[5, :]*2

Подобные матричные преобразования возможны, поскольку выделение подполя массива не копирует никакие данные. Вместо этого формируется новая заголовочная структура, инициализируется её размер, тип и размерность, а затем она указывает на оригинал массива с некоторым смещением. Счетчик ссылок оригинального массива увеличивается. Имеются два исключения из этого правила:

    Если в диапазоне подполя использован отрицательный шаг или ненулевой шаг в последней размерности, то субмассив придется скопировать в новую позицию.
    Выполнена операция flatten (arr[:]), а массив несмежный. В этом случае данные также подлежат копированию.

Когда подполе массива больше не нужно, оно уничтожается, и счетчик ссылок уменьшается.

Обращение к элементам массива

Когда в программе встречается обращение к элементу массива A[i, j, k, ...], компилятор Ficus генерирует код, подобный следующему псевдокоду:

if (i < 0 || i >= A.size[0] ||
   j < 0 || j >= A.size[1] ||
   k < 0 || k >= A.size[2] ||
   ...) {
    __throw__(OutOfRangeError);
}
elemtype* ptr = (elemtype*)(A.data + A.step[0]*i +
                   A.step[1]*j + A.step[2]*k + ... );

Другими словами, каждая операция обращения к элементу проверяет, попадает ли индекс элемента в границы массива. Если индекс выходит за рамки, возникает исключение OutOfRangeError. Несмотря на то, что это повышает безопасность и помогает оперативно находить ошибки, это может замедлить доступ к массивам. При выборе диапазонов вместо конкретных индексов границы также проверяются, но накладные расходы намного ниже.

Для увеличения производительности и поддержания безопасности компилятор Ficus применяет особые оптимизации, снижающие количество проверок границ:

    Если массив обращается безусловным образом (то есть не внутри вложенных операторов if, match, try и т.д.) внутри цикла for,
    Если индекс ij является линейной комбинацией индекса цикла и некоторых инвариантов цикла: ij == loop_idx*loop_inv + another_loop_inv

Тогда проверка границ перемещается за пределы цикла и заменяется проверкой, входят ли минимальный и максимальный индексы цикла в границы массива.

Рассмотрим пример реализации функции умножения матриц, приведённой ранее:

fun matmul(A: double [,], B: double [,])
{
    val (ma, na) = size(A), (mb, nb) = size(B)
    assert(na == mb)
    [for i <- 0:ma for j <- 0:nb {
        fold s = 0. for k <- 0:na {s + A[i,k]*B[k,j]}
     }]
}

Генерируемый код (псевдокод на языке Ficus) выглядел бы так:

fun matmul(A: double [,], B: double [,])
{
    val (ma, na) = size(A), (mb, nb) = size(B)
    assert(na == mb)
    // Проверяем границы массива для индексов i и j
    check_range(0, ma, 1, 0, A, 0)
    check_range(0, nb, 1, 0, B, 1)
    [for i <- 0:ma for j <- 0:nb {
        // Аналогично проверяем индекс k
        check_range(0, na, 1, 0, A, 1)
        check_range(0, na, 1, 0, B, 0)
        // <.> обозначает быстрый доступ без проверки границ,
        // это не реальный синтаксис Ficus
        fold s = 0. for k <- 0:na {s + A[<i>,<k>]*B[<k>,<j>]}
     }]
}

В теории последующая версия компилятора могла бы перенести последние две проверки за пределы внешнего цикла.

Быстрее всего обращаться к элементам массива можно посредством прямого запроса в заголовке цикла for, например:

// здесь x извлекается с помощью *(указатель_на_субмассив + индекс_цикла) на уровне C-кода
fold sum = 0. for x <- arr {s + x}

Достоинства такого подхода:

    Проверка границ не требуется, так как очевидно, что мы проходим по всему массиву.
    Адрес элемента не нужно заново вычислять, достаточно увеличить индекс цикла и простым действием обратиться к элементу. Особенно полезно это в случае прохода по двумерной матрице, когда перед внутренним циклом устанавливается указатель на текущую строку матрицы, а затем он используется как базовый указатель, добавляющийся к индексу цикла для получения текущего элемента матрицы. Такой подход необходим, поскольку матрица не обязана быть смежной (может быть подматрицей большего массива).

Поэтому, если нам необходимы как элемент, так и его индекс, лучше запросить их оба в заголовке цикла for, чем обращаться к элементу через оператор [].

