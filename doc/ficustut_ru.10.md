Интерфейсы

Интерфейс — это совокупность объявлений функций. Любой класс в Ficus может реализовать ноль или более интерфейсов. Если класс Class реализует интерфейс Inter, то его экземпляр obj можно привести к нему с помощью оператора (obj :> Inter). В результате получаем указатель на интерфейс, который фактически является парой (указатель_на_таблицу_методов_интерфейса_Inter, obj). Этот указатель на интерфейс можно приводить к любым другим интерфейсам, которые реализует класс Class, а также обратно к самому классу Class. В случае неуспешного приведения возникнет исключение TypeMismatchError. Последние два преобразования напоминают оператор dynamic_cast<T>() в C++.

Простой пример:

// определим базовый интерфейс, который потребует от класса способности называться
interface IBase
{
    fun name(): string
}

// другой интерфейс, позволяющий клону воспроизводить себя
interface IClone
{
    fun clone(): IClone
}

type color_t = uint8*3

// интерфейс фигуры для геометрических объектов,
// например, для редактора векторной графики
interface IShape : IBase
{
    fun draw(img: color_t[,]): void
    fun area(): float
    fun get_scale(): (float, float)
    fun set_scale(fx: float, fy: float): void
    fun perimeter(): float
    fun center(): (float, float)
    fun bbox(): bbox_t
    fun move_to(dx: float, dy: float): void
    fun get_scale(): (float, float)
    fun rotate(angle: float): void
    fun setcolor(sc: color_t): void
    fun getcolor(): color_t
}

// объект-прямоугольник, умеющий клонироваться и выступающий фигурой
class Rect : IShape, IClone
{
    var cx: float
    var cy: float
    var fx: float
    var fy: float
    var angle: float=0.f
    var corner_r: float=0.f
    var sc: shape_colors_t
}

// эллипс — другая фигура
class Ellipse : IClone, IShape
{
    var cx: float
    var cy: float
    var fx: float
    var fy: float
    var angle: float=0.f
    var sc: shape_colors_t
}

// реализуем некоторые методы
fun Rect.name() = "прямоугольник"
fun Rect.area() = self.fx*self.fy
fun Rect.get_scale() = (self.fx, self.fy)
fun Rect.set_scale(fx: float, fy: float)
   { self.fx = fx; self.fy = fy }
fun Rect.clone()
{
    val {cx, cy, fx, fy, angle, corner_r, sc} = self
    (Rect {cx=cx, cy=cy, fx=fx, fy=fy, angle=angle,
           corner_r=corner_r, sc=sc} :> IClone)
}
fun Rect.draw(canvas: color_t[,]) {...}

fun Ellipse.name() = "эллипс"
fun Ellipse.area() = float(M_PI*self.fx*self.fy)
fun Ellipse.get_scale() = (self.fx, self.fy)
fun Ellipse.set_scale(fx: float, fy: float)
  { self.fx = fx; self.fy = fy }
fun Ellipse.clone()
{
    val {cx, cy, fx, fy, angle, sc} = self
    (Ellipse {cx=cx, cy=cy, fx=fx,
     fy=fy, angle=angle, sc=sc} :> IClone)
}
fun Ellipse.draw(canvas: color_t[,]) {...}
...
val r0 = Rect {cx=100.f, cy=100.f, fx=16.f, fy=10.f, sc=color_red}
val e0 = Ellipse {cx=150.f, cy=100.f, fx=20.f, fy=20.f, sc=color_blue}

// создадим небольшую коллекцию фигур;
// поскольку разнородный список невозможен,
// приведём все созданные фигуры к интерфейсу IShape
// и объединим их в список 'IShape list'
val shapes = [(r0 :> IShape), (e0 :> IShape)]
val canvas = array((800, 800), (255u8, 255u8, 255u8))
// рисуем все фигуры
for s <- shapes { s.draw(canvas) }

Наследование и полиморфизм

Согласно классической литературе по объектно-ориентированным языкам, основными составляющими ООП являются:

    Инкапсуляция, т.е. класс инкапсулирует данные и предоставляет методы для их обработки. Ficus частично поддерживает эту концепцию.
    Наследование. В Ficus классического наследования нет, т.е. диаграмма наследования в программах на Ficus максимально двууровневая. Большинство классов, обобщённые или нет, являются самостоятельными готовыми структурами данных. В стандартной библиотеке примером таких классов являются File.t или Hashmap.t. Могут существовать двууровневые схемы наследования, где на нижнем уровне располагаются абстрактные интерфейсы, объявляемые ключевым словом interface, а на верхнем уровне находится класс, реализующий один или несколько интерфейсов. Пока что таких классов в стандартной библиотеке Ficus нет.
    Полиморфизм, т.е. способность писать обобщённый код, применимый к различным типам, при этом поведение адаптируется соответствующим образом. Ficus поддерживает три типа полиморфизма:
        Перегрузка функций, или ад-хок-полиморфизм;
        Параметрический полиморфизм, или шаблоны (generics);
        Полиморфизм стиля ООП. Реализуется с помощью интерфейсов и соответствующего оператора приведения.

Вопросы производительности

Поддержка ООП в Ficus чрезвычайно эффективна. Вызов метода класса по быстродействию не уступает обычной функции. Таблица виртуальных методов используется только в случае, когда экземпляр класса приведён к указателю на интерфейс, и затем вызван метод интерфейса, т.е. когда компилятор не может однозначно определить, какой именно метод вызывать:

interface Printable
{
    fun print_me(): void
}

class A: Printable
{
    ...
}
fun A.print_me() = ...

class B: Printable
{
    ...
}
fun B.print_me() = ...

val rng = RNG(123u64)
fun get_some_printable(): Printable
{
    if bool(rng) {(A {...} :> Printable)}
    else {(B {...} :> Printable)}
}

fun foo(p: Printable)
{
    // непонятно, вызывать ли A.print_me(),
    // B.print_me() или что-то ещё;
    // поэтому вызов print_me() происходит через таблицу виртуальных методов
    p.print_me()
}

foo(get_some_printable())

Параллельное программирование

Хорошая поддержка параллельного программирования была одной из главных целей проектирования Ficus. Хотя полноценного высокоуровневого фреймворка параллельного программирования пока нет, уже реализовано несколько удобных примитивов и синтаксических конструкций, покрывающих базовые потребности вычислительной области.

Первый полезный инструмент — директива @parallel for:

val (h, w) = size(img)
val out_img = [
    @parallel for y <- 0:h
        for x <- 0:w {
            some_time_consuming_filter(img, x, y)
        }]

То есть вы пишете обычный цикл или генератор массива, ставите перед for директиву @parallel, и готово. Компилятор Ficus автоматически превратит этот цикл в параллельный. Иллюстрацией этой особенности служит пример рендеринга фрактала Мандельброта в файле examples/mandelbrot.fx.
Концепция Map-Reduce

Когда требуется обработать огромный объем данных, решение традиционно включает два этапа:

    Логически разделить данные по какому-то критерию на приблизительно равные по вычислительной сложности части и обрабатывать их параллельно с использованием нескольких ядер ЦПУ (или даже машин).
    Объединить полученные независимо результаты.

Этот двухэтапный подход называется концепцией Map-Reduce. Первый этап прекрасно решается с помощью @parallel for.

Второй этап теоретически можно провести последовательно после окончания цикла. Однако это неудобно и неэффективно, так как нам пришлось бы поддерживать столько отдельных хранилищ для выходящих данных, сколько задействовано рабочих потоков или ядер. Бывают ситуации, когда количество работающих потоков меняется со временем и заранее неизвестно, что усложняет организацию процесса.

В качестве возможного решения в языках программирования или параллельных фреймворках предлагается концепция синхронных участков (synchronous sections) внутри параллельных циклов. Она позволяет рабочим потокам получать эксклюзивный доступ к выходной памяти и сохранять туда данные прямо в процессе выполнения параллельного цикла. Благодаря эксклюзивности доступа риск повреждения данных исключён. Более общее назначение таких синхронных участков — обмен информацией между рабочими потоками.

В Ficus это делается с помощью директив @sync. Пример:

fun is_prime(n: int) {
    if n <= 1 {false} else if n % 2 == 0 {n == 2}
    else {
        all(for d<-3:floor(sqrt(double(n)))+1:2 {n % d != 0})
    }
}

var primes: int list = []
@parallel for i <- 10000000:10100000 {
    if is_prime(i) @sync {
        primes = i :: primes
    }
}

Здесь мы пытаемся найти большие простые числа в параллельном цикле. Все найденные простые числа заносятся в список. Так как простых чисел немного, нам не нужно часто писать в выходной список. Однако нужно гарантировать эксклюзивность доступа. Для этого ветвь then выражения if помечаем ключевым словом @sync, что гарантирует эксклюзивность. Ключевое слово @sync может сопровождаться необязательным идентификатором (id), который может содержать точки в своём имени. Все участки синхронизации с одинаковыми идентификаторами будут использовать один и тот же внутренний механизм синхронизации («мутекса» или критической секции), защищая определённые структуры данных независимо от месторасположения в программе.
Совместимость с C

Так как компилятор Ficus генерирует код на C, вызов функций C/C++ из Ficus прост. Вы можете вставлять фрагменты кода на C прямо в вашу программу с помощью оператора @ccode {код на C ... }. Впрочем, вставлять такой код можно не везде, а только в трёх разрешённых местах:

    На вершине уровня модуля. Подобные фрагменты часто используются для включения заголовков и определения вспомогательных функций и макросов.
    Для определения тела функции (всегда требуется явно указать тип возвращаемого значения):

fun func_name(arg1: T1, arg2: T2, ...): explicit_rettype
@ccode {
    // тут код на C
    ...
}

    Для определения значений:

val identifier : explicit_type_spec = @ccode { c_code_value }

Вот как, например, можно реализовать модуль с функциями обработки массивов, оптимизированными для SSE (включён только один метод для иллюстрации):

// SSE2_Utils.fx
@ccode {
#if defined __SSE2__ || defined _M_X64
#include "emmintrin.h"
#else
#error "SSE2 инструкции не поддерживаются"
#endif
typedef unsigned char uchar;
}

fun add_sat_u8(a: uint8[], b: uint8[]): uint8[]
{
    // основную работу выполняет вложенная функция,
    // тогда как интерфейсная функция проверяет все параметры
    // и выделяет выходной массив
    val (na, nb) = (size(a), size(b))
    if na != nb {throw SizeMismatchError}
    val result = array(na, 0u8)

    fun add_sat_u8_(a: uint8[], b: uint8[],
                    result: uint8[]): void
    @ccode {
        // доступ к массивам
        int i, n = a->dim[0].size;
        uchar* aptr = (uchar*)a->data;
        uchar* bptr = (uchar*)b->data;
        uchar* rptr = (uchar*)result->data;

        for( i = 0; i <= n - 16; i += 16 )
        {
            __m128i aval = _mm_loadu_si128(
                 (const __m128i*)(aptr + i));
            __m128i bval = _mm_loadu_si128(
                (const __m128i*)(bptr + i));
            _mm_storeu_si128((__m128i*)(rptr + i),
                _mm_adds_epu8(aval, bval));
        }
        for( ; i < n; i++ )
        {
            int res = aptr[i] + bptr[i];
            rptr[i] = (uchar)(res <= 255 ? res : 255);
        }
        return FX_OK;
    }
    add_sat_u8_(a, b, result)
    result
}
...

Вот как это можно использовать:

import SSE2_Utils as sse2
val n = 42
val a = array(n, 200u8)
val b = [for i <- 0:n {uint8(i*5)}]
println(sse2.add_sat_u8(a, b))

Многие функции стандартной библиотеки Ficus реализованы на C, например большая часть содержимого модуля File или некоторые функции обработки матриц в модуле Array. Ознакомьтесь с их реализацией, чтобы глубже изучить тему.
Обзор стандартной библиотеки
Math

Модуль Math автоматически импортируется. Включает различные математические функции:

    Константы: M_PI, M_E, M_LOG2 — π≈3.14159..., основание натурального логарифма ≈2.71828..., log₂(2)≈0.693147...
    Константы погрешности: FLT_EPSILON, DBL_EPSILON — минимальные значения для типов с плавающей точкой, при которых сумма единицы и числа больше единицы.
    Стандартные математические функции: pow(x, y), sqrt(x), asin(x), acos(x), atan(x), atan2(y, x), cos(x), sin(x), tan(x), log(x), exp(x), acosh(x), asinh(x), atanh(x), cosh(x), sinh(x), tanh(x) — принимают аргументы типа float или double.
    Округление: ceil(x), floor(x), round(x), trunc(x) — округляют числа с плавающей точкой до ближайшего целого числа. Округление происходит соответственно к положительной бесконечности, отрицательной бесконечности, ближайшему чётному числу или нулю.
    Проверка на NaN и бесконечность: isnan(x), isinf(x) — возвращают истину, если аргумент является неопределённым числом или бесконечностью.
    Наибольший общий делитель: GCD(x: int, y: int): int — находит наибольший общий делитель двух целых чисел.
    Генератор случайных чисел: RNG — класс генератора случайных чисел.

File

Модуль File в стандартной библиотеке реализует всю функциональность стандартной библиотеки C stdio.h. Вот список полезных функций и методов (предполагается, что экземпляр класса назван file):

    File.open(filename, mode): File.t — открывает файл в требуемом режиме, аналогично функции fopen из C. Возбуждает исключение FileOpenError, если файл не найден или не удаётся открыть. В противном случае возвращает экземпляр класса File.t, чьи методы перечислены ниже.
    file.eof(): bool — возвращает true, если достигнут конец файла.
    file.close(): void — закрывает файл. Закрытие дважды безопасно, вторая попытка будет проигнорирована. Кстати, файл автоматически закрывается в деструкторе.
    file.seek(pos, origin): void — меняет положение в файле согласно указанной позиции. Аргумент origin может принимать значения SEEK_SET, SEEK_CURR или SEEK_END.
    file.tell(): int64 — возвращает текущую позицию в файле.
    file.print(x): void — выводит значение в текстовый файл, перегруженные функции для различных элементарных типов.
    file.println(x): void — аналогично предыдущему, но добавляет символ перевода строки \n.
    file.write(arr): void — записывает 1D или 2D массив в бинарный файл.
    file.read(arr): int — читает данные в 1D массив типа uint8. Чтение продолжается до заполнения всего массива или наступления конца файла. Возвращает количество прочитанных байт.
    file.readln(): string — читает одну строку из текстового файла. Предполагается, что файл закодирован в UTF-8, и прочитанная строка преобразуется в юникод.
    File.read_utf8(filename): string — читает весь файл, считая его текстом в кодировке UTF-8, в текстовую строку.
    File.write_utf8(filename, str): void — записывает строку (возможно, содержащую символы \n, \r) в файл, используя кодировку UTF-8.
    File.read_binary_u8(filename): uint8[] — читает весь файл (в бинарном режиме) в массив байтов.

Filename

Модуль Filename содержит функции для манипуляций с путями к файлам:

    Filename.is_absolute(path) — возвращает true, если путь абсолютный.
    Filename.is_relative(path) — возвращает true, если путь относительный.
    Filename.split(path) — возвращает кортеж (dirname, filename).
    Filename.dirname(path) — возвращает имя каталога (Filename.split(path).0).
    Filename.basename(path) — возвращает базовое имя файла (Filename.split(path).1).
    Filename.concat(dir, fname) — соединяет имя каталога и имя файла в единый путь.
    Filename.normalize(dir, fname) — если fname относительный путь, соединяет имя каталога и fname в единый путь, иначе возвращает fname.
    Filename.remove_extension(path) — удаляет расширение из имени файла.
    Filename.getcwd() — возвращает текущий рабочий каталог.
    Filename.exists(path) — возвращает true, если указанный файл или каталог существует.
    Filename.locate(name, dirs) — ищет имя файла среди указанных каталогов.

Sys

    Sys.argv: string list — список аргументов командной строки.
    Sys.win32: bool — возвращает true, если приложение запущено на Windows.
    Sys.unix: bool — возвращает true, если приложение запущено на ОС семейства Unix (Linux, macOS, BSD и т.д.).
    Sys.osname(get_version: bool): string — возвращает текстовое описание операционной системы, на которой запущено приложение. Выполните тесты Ficus (или запустите Ficus с параметром -v), чтобы увидеть вывод этой функции на вашей платформе.
    Sys.cc_version(): string — возвращает информацию о компиляторе и его версии, использовавшихся для сборки приложения.
    Sys.tick_count(): int64 — возвращает количество тиктов реального времени с момента старта системы.
    Sys.tick_frequency(): double — возвращает частоту тиков (количество тиков в секунду).
    Sys.timeit(f: void->void, ~iterations=1, ~batch=1): double — измеряет среднее время выполнения функции за указанное количество итераций, выполняя каждую итерацию заданное количество раз (batch). Возвращает геометрическое среднее времени выполнения функции.
    Sys.remove(filename) — удаляет файл.
    Sys.rename(filename, newname) — переименовывает файл.
    Sys.mkdir(dirname, permissions) — создаёт каталог.
    Sys.command(cmd): int — запускает команду, возвращает код завершения.
    Sys.getenv(varname): string — возвращает значение переменной окружения.
    Sys.getpath(varname): string list — разбирает переменную окружения, содержащую список путей, разделённых символом : (Unix) или ; (Windows), и возвращает список каталогов.
    Sys.colorterm(): bool — возвращает true, если приложение запущено в терминале, поддерживающем ANSI escape-коды.

Hashmap, Hashset

TBD (см. пример подсчёта слов выше)Эффективные императивные структуры данных для хеш-таблиц и множеств.
Map, Set

TBD (см. тест test_ds.fx)Чисто функциональные структуры данных, основанные на красно-чёрных деревьях.
Json

Парсер и красивый принтер формата JSON, см. пример использования в тестовом файле test_json.fx.

    Json.parse_file(filename): Json.t — парсит файл, возвращает иерархическое представление JSON.
    Json.parse_string(string): Json.t — парсит строку, возвращает иерархическое представление JSON.
    Json.print_to_file(json, filename) — выводит JSON-представление в файл.
    Json.print(json) — выводит JSON-представление на стандартный вывод.
    Json.string(json) — преобразует JSON-представление в строку.

Приложение A. Использование Ficus

(Будет детально объяснено)