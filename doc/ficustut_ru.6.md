### Унарный оператор `.-`

В Python удобно получать последний элемент строки или списка с помощью отрицательных индексов, например, python\_str\[-1\] возвращает последний символ строки.

В Ficus, как мы недавно узнали, подобная операция приведет к исключению `OutOfRangeError`, что зачастую и требуется. Однако в Ficus предусмотрен оператор `.-`, предназначенный для доступа к последнему, предпоследнему и т.д. элементам. То есть вместо использования выражений вида `N1-i1`, `N2-i2`, где `Nj` — размер соответствующего измерения массива, а `ij` — индекс, можно просто поставить точку вместо `N1`, `N2` и т.д.:

* `A[0, .-1]` — доступ к верхнему правому углу матрицы
* `A[.-1, .-1]` — доступ к нижнему правому углу матрицы
* `A[:.-1]` — взятие всех элементов одномерного массива, кроме последнего

## Базовые операции с массивами

Ниже приведены некоторые базовые операции обработки массивов, собранные для удобства:

 1. Получить размер или форму массива: `size(A)`. Узнать размер i-го измерения: `__intrin_size__(A, i)`
 2. Извлечь строку матрицы: `A[i, :]`
 3. Извлечь столбец матрицы: `A[:, i]`
 4. Извлечь четные строки: `A[::2, :]`. Это можно сделать без копирования элементов матрицы.
 5. Отразить матрицу вокруг горизонтальной оси, то есть перевернуть порядок строк: `A[::-1,:]`
 6. Отразить матрицу вокруг вертикальной оси, то есть перевернуть каждую строку: `A[:,::-1]`
 7. Отразить матрицу симметрично относительно центра: `A[::-1,::-1]`
 8. Сплющить массив, превратив его в одномерный: `A[:]`
 9. Применить поэлементную бинарную операцию к каждому соответствующему элементу пары матриц: `A op B`, где `op` — один из операторов `.+`, `.-`, `.*`, `./`, `.%`, `.**`, `&`, `|,` `^`.
10. Горизонтально соединить несколько массивов: `[\A1, \A2, ...]`
11. Вертикально соединить несколько массивов: `[\A1; \A2; ...]`
12. Преобразовать список или строку в массив: `[\source]`
13. Преобразовать массив обратно в список или строку: `list(arr)`, `string(arr)`. Во втором случае массив должен иметь тип `char []`, иначе функция `string(arr)` создаст текстовое представление массива.
14. Объединить несколько массивов в многоканальный массив: `[for x1 <- A1, x2 <- A2, ... {(x1, x2, ...)}]` TODO
15. Разделить многоканальный массив на несколько одноканальных массивов: `[@unzip for x <- A {x}]`
16. Транспонировать матрицу с помощью апострофа после оператора: `A'`
17. Умножить две матрицы: `A*B`
18. Инвертировать матрицу (текущие реализации используют QR-алгоритм): `A\1`
19. Решить систему уравнений вида `Ax=b`: `A\b`
20. Вычислить детерминант или след матрицы: `det(A)`, `trace(A)`
21. Отсортировать элементы одномерного массива согласно пользовательскому критерию упорядоченности: `sort(A, less_than)`
22. Вычислить сумму, среднее значение, нормы L∞, L₁ или L₂ (также известную как норма Фробениуса) массива: sum(A), mean(A), normInf(A), normL1(A), normL2(A). Для вариантов функций norm\* с двумя параметрами вычисляется норма разницы между двумя массивами.

## Экспраполяция границ

В обработке сигналов, изображений и глубоком обучении нередко возникает потребность обращаться к массиву за пределами его границ. Например, при применении фильтра к изображению, скажем, Гауссова размытия, для каждого пикселя, включая краевые и угловые, нужно вычислить взвешенную сумму окрестности размеров **2R\+1 × 2R\+1**, где `R` — радиус фильтра. Возможные подходы к решению этой задачи:

1. создавать на выходе массив меньшего размера, обрабатывая только те элементы входного массива, которые достаточно удалены от границы.
2. Копировать массив в центр нового увеличенного массива, заполняя оставшиеся элементы новым массивом с помощью определенной формулы (например, распространение крайних элементов исходного массива на границу нового массива):

```
// Исходный массив:
a b c d
e f g h

// Расширенный массив с радиусом 2:
a a a b c d d d
a a a b c d d d
a a a b c d d d
e e e f g h h h
e e e f g h h h
e e e f g h h h
```

3. Изменить алгоритм так, чтобы каждый доступ к элементам входного массива заменялся более сложной формулой, например, вместо `A[i, j]` использовать нечто вроде `A[min(max(i, 0), M), min(max(j, 0), N)]`.

4. Разделить цикл обработки массива на несколько частей (минимум на две), где основная "быстрая" часть обрабатывает внутреннюю область массива без учета границ (метод 1 в этом списке), а затем обработать граничные элементы с помощью метода 3.

Выбор конкретной стратегии зависит от приложения и ряда обстоятельств, таких как размер массива, радиус экстраполяции, сложность фильтра и т.д. Любой из четырех подходов может оказаться полезным.

Ficus пытается облегчить реализацию методов №3 и №4, вводя специальные разновидности операций доступа к элементам массива:

* `A.clip[i1, i2, ...]` — доступ к элементам массива с отсечением. Каждый индекс `ij` ограничивается с помощью формулы `min(max(ij,0),Nj)`, где `Nj` == `__intrin_size__(A,j)`.
* `A.zero[i1, i2, ...]` — доступ к элементам массива с дополнением нулями. Если любой из индексов ij выходит за пределы диапазона \[0,Nj), возвращается ноль (того же типа, что и элементы массива; для многоканального массива возвращается нулевой кортеж).
* `A.wrap[i1, i2, ...]` — доступ к элементам массива с цикличным повторением. Индекс `ij` обрабатывается по формуле `ij mod Nj`, где `mod` — операция взятия остатка от деления, возвращающая неотрицательные значения. Например, для одномерного массива `A.wrap[N1] ~ A[0]`, `A.wrap[N1+1] ~ A[1]`, `A.wrap[-1] ~ A[N1-1]`.

Операции экстраполяции границ имеют ограничения и особенности:

* их нельзя использовать с диапазонами; все индексы должны быть скалярными значениями.
* эти операции применимы только к массивам, чьи элементы являются скалярными значениями (числа, `bool`, `char`) или кортежами скалярных значений.
* ни одна из этих операций не генерирует исключение. `.clip` и `.wrap` всегда возвращают один из элементов массива, если массив не пуст. Если массив пустой, возвращается нулевой элемент (аналогично `.zero`).
* данные операции могут применяться не только к массивам, но и к объектам типа `vector` и `string`.

Вот наивная, но рабочая реализация фильтра размытия 3x3 с использованием операции .clip:

```
fun blur3x3(img: uint8 [,])
{
   val (h, w) = size(img)
   [for y <- 0:h for x <- 0:w {
	  sat_uint8((img.clip[y-1, x-1] + img.clip[y-1, x] +
				 img.clip[y-1, x+1]+ img.clip[y, x-1] +
				 img[y, x] + img.clip[y, x+1]+
				 img.clip[y+1, x-1] + img.clip[y+1, x] +
				 img.clip[y+1, x+1])/9)
	 }]
}
```

В качестве упражнения попробуйте реализовать вариант этой функции, который:

* создает выходной массив размера `h×w` с помощью `array((h, w), 0u8)`
* вычисляет центральную часть результата, используя цикл по диапазону `1≤y<h-1`, `1≤x<w-1`. В этом цикле компилятор Ficus должен исключить проверку границ, так как мы гарантированно остаемся в пределах исходного изображения.
* рассчитывает границы результата с помощью операции `.clip`. Вероятно, эту часть можно оформить в отдельную функцию, так как она должна вызываться четыре раза для каждой границы.

# Управление памятью

Перед тем как перейти к другим типам данных, сделаем короткую паузу и обсудим, каким образом различные структуры данных выделяются, копируются, изменяются и освобождаются в Ficus.

Все структуры данных можно сгруппировать по двум признакам:

1. Первый признак — изменяемость:

   * числа, булевы значения, указатели на структуры C (`cptr`), строки, символы, списки, векторы, кортежи, записи без изменяемых членов, варианты — неизменяемые структуры данных. Невозможно изменить часть такой структуры.

   * Массивы, ссылки и записи с изменяемыми членами — изменяемые структуры данных.

   Конечно, если неизменяемая структура записана в переменную, вы можете позднее присвоить ей другую структуру, но изменить первоначальную структуру нельзя. Подробнее см. раздел [Кортежи и записи](), где описан один нюанс, фактически не являющийся исключением.

2. Второй признак — способ распределения памяти:

   * Числа, булевы значения, символы, кортежи, записи без изменяемых членов, нерекурсивные варианты хранятся непосредственно на стеке или внутри контейнера родителя (массива, вектора, списка, другой записи, кортежа и т.д.). Назовем такие объекты распределёнными на стеке.
   * Строки, списки, рекурсивные варианты, массивы, ссылки, записи с изменяемыми членами, указатели на структуры C (`cptr`) — это структуры, выделяемые на куче. Сам заголовок может находиться на стеке или внутри контейнера, но есть скрытая часть («подводная»), которая всегда располагается на куче, вместе со связанным счётчиком ссылок.

Отсюда вытекает несколько важных моментов:

* на стеке могут быть размещены только неизменяемые структуры.
* структуры данных, чьё распределение памяти не может быть вычислено на этапе компиляции, всегда размещаются на куче, независимо от того, изменяемые они или нет.
* Хотя кортежи и располагаются на стеке, они могут содержать элементы, размещённые в куче и снабжённые соответствующим счётчиком ссылок. Это нормальное явление, и компилятор Ficus корректно управляет такими ситуациями.

Итак, что происходит, когда вы пишете `val x = expr`, то есть исполняете выражение и сохраняете результат в переменной или значении?

* если expr — структура, выделяемая на стеке (число, кортеж и т.д.), она сохраняется на стеке, все её элементы (некоторые из которых могут быть заголовками кучно распределённых структур) копируются. Часто в сгенерированном коде, если компилятор знает, что результат выражения `expr` будет сохранён в `x`, он устанавливает результирующий адрес сразу в `x`.

* если expr — структура, выделяемая на куче, на стеке сохраняется только её заголовок. Счётчик ссылок может увеличиваться или оставаться прежним; компилятор Ficus проводит оптимизацию, устраняя лишние пары `incref`/`decref`. При начальном выделении новой структуры её счётчик ссылок устанавливается в 1.

Что происходит, когда вы пишете `var x = ...; ... x = expr`, то есть заменяете содержимое переменной новым значением, или изменяете изменяемую структуру данных, например, элемент массива?

* если `x` и `expr` — неизменяемые структуры, выделяемые на стеке, новое содержимое просто переписывает старое. Если речь идет о кортеже, элементы которого могут быть выделены на куче, они обрабатываются отдельно вторым способом, указанным ниже.

* если `x` и `expr` — структуры, выделяемые на куче, то:

  - счётчик ссылок `expr` увеличивается.
  - счётчик ссылок объекта, хранившегося в `x`, уменьшается, и при достижении нуля вызывается соответствующая процедура освобождения ресурсов.
  - cодержимое `x` (заголовок структуры, выделенной на куче) заменяется на `expr`.

Что происходит, когда переменная `val x = expr` создана в теле функции, цикла или другого блока, а программа покидает область видимости?

* в случае структуры, выделенной на стеке ничего не происходит. Как и ранее, части стековых элементов, расположенные в куче, обрабатываются обычным образом.
* в случае структуры, выделенной на куче, её счётчик ссылок уменьшается, и если он достигает нуля, вызывается соответствующая процедура освобождения ресурсов.

Естественно, если структура на куче является контейнером для других структур на куче (например, массив массивов), процедура освобождения уменьшает счётчики ссылок содержащихся элементов и вызывает их освобождение при необходимости.

Таблице собраны особенности поведения программы для различных типов данных:


|Тип данных|Изменяемость|Метод размещения|Способ копирования|
|:---:|:---:|:---:|:---:|
|Число, `bool`, `char`|нет|стек|полное копирование|
|Кортеж|нет|стек|полное копирование|
|Запись без изменяемых членов|нет|стек|полное копирование|
|Запись с изменяемыми членами|да|куча|увеличение счётчика ссылок|
|Строка|нет|куча|копирование заголовка, увеличение счётчика ссылок|
|Список|нет|куча|увеличение счётчика ссылок ячейки заголовка|
|Вектор|нет|куча|копирование заголовка, увеличение счётчика ссылок|
|Ссылка|да|куча|увеличение счётчика ссылок|
|Массив|да|куча|копирование заголовка, увеличение счётчика ссылок|
|Немасштабируемый вариант|нет|стек|полное копирование|
|Масштабируемый вариант|нет|куча|увеличение счётчика ссылок корня|
|Класс без интерфейсов|?|?|аналогично записям|
|Класс с интерфейсами|?|куча|увеличение счётчика ссылок|
|Интерфейс|нет|стек|см. раздел [Интерфейсы]()|

Подытоживая, Ficus автоматически управляет всей памятью, и большую часть времени разработчику не нужно заботиться об управлении ресурсами. Поведение оператора присваивания полностью определяется типом данных, и его нельзя переопределить.
Увеличение/уменьшение счётчиков ссылок выполняются потокобезопасными атомарными операциями.
Кроме того, Ficus использует высокопроизводительный параллельный менеджер памяти, настроенный на эффективное распределение небольших блоков и хорошую работу в многопоточной среде.

## Потребление стека

Фундаментальной особенностью стиля функционального программирования является активное применение рекурсивных функций, что влечет за собой значительную нагрузку на стек и повышает вероятность возникновения ситуации переполнения стека. Для предотвращения подобной проблемы предусмотрены три основных метода защиты:

1. Рекомендуется использовать хвостовую рекурсию. Большинство рекурсивных алгоритмов допускают реализацию в форме хвостовых рекурсий. Компилятор Ficus гарантированно преобразует подобные функции в циклические конструкции, даже если сборка осуществляется в отладочном режиме без оптимизации, благодаря чему такие функции практически не расходуют значительный объем памяти стека.
2. Можно настроить конфигурационные параметры вашей системы либо установить соответствующие опции компилятора C для повышения предустановленного лимита объема стека (например, воспользоваться командой `setrlimit` в системах семейства Linux).
3. В ситуациях, когда возникает угроза переполнения стека, среда выполнения Ficus генерирует специальное исключение класса `StackOverflow`.

# Строки символов

Мы уже неоднократно сталкивались со строками в данном руководстве и знаем, каким образом они обрабатываются внутри. Давайте рассмотрим некоторые пропущенные моменты.

Строки в Ficus представляют собой Unicode-последовательности, состоящие из четырёхбайтовых символов (каждый символ имеет тип `char`).

Создать новую строку можно одним из следующих способов:

* с помощью строковых литералов. Сейчас поддерживаются литералы трёх видов: `""`, `f""` и `r""`.
* первый вариант, `""`, представляет обычную текстовую строку. Она может включать символы перевода строки, которые удаляются или сохраняются в зависимости от наличия перед символом переноса строки обратной косой черты ё `\`. Также возможно включение любых обычных экранированных последовательностей языка C.
* второй вид, `f""`, технически говоря, не является литералом. Такой синтаксис интерпретируется как конкатенация литерала строки и вызов функции `string()` для преобразования интерполированных выражений в строки.
* третий вид используется преимущественно для регулярных выражений, поскольку не поддерживает никаких экранированных последовательсностей, кроме `\\` и `\"`, представляемых буквально двумя символами.
* как результат определённых операций, порождающих строки
* (частичный, но важный случай предыдущего пункта) результатом вызова функций `string()` или `repr()`. Для большинства типов данных Ficus автоматически генерируется функция `string()`, которую можно переопределять и которая отображает значения данных в удобочитаемую текстовую форму. Различие между функциями `string()` и `repr()` заключается в том, что первая стремится обеспечить читаемость результата, тогда как вторая формирует строку, близкую к исходному виду выражения в коде Ficus (так, будто оно было задано в виде литерала).

Каждая строка хранит свою длину, получаемую функцией `length(str)`. Строка необязательно должна завершаться нулевым байтом. Доступ к отдельным символам строки возможен через оператор индексирования `str[i]`, а извлечение части строки производится оператором среза `str[начало:конец:шаг]`, где отрицательное значение шага означает обращение к строке задом наперёд. Если шаг отсутствует или равен единице, извлечённая подстрока не копируется отдельно, а лишь адресует участок родительской строки (поэтому строка необязательно заканчивается нулём).

Также поддерживается специальный синтаксис, аналогичный описанному в разделе [Массивы]():

* `str.clip[i]`, `str.wrap[i]`, `str.zero[i]` (`str.zero[i]` возвращает `\0` в случае выхода индекса за пределы диапазона).
* `str[.-n]`

Вот несколько примеров построения и обработки строк (см. также описание литералов строк в разделе Структура кода и лексические соглашения):

```
val s = "abc"
val s6 = s + "def" # "abcdef"
val right4 = s6[2:] # "cdef"

//  верно, так как "abc" лексикографически предшествует "abcdef"
val f = s < s6

// итерация по строке:
//выводим коды символов Unicode
for c <- s { println(ord(c)) }

//создание повторяющейся строки
val indent = " "*4

val strlist = "sin" :: "cos" :: "tan" :: []
// конкатенация строк: "sin, cos, tan"
val str = ", ".join(strlist)
```

Кроме того, имеется ряд полезных возможностей модуля String. Вместо записи вида `str.foo([args])` можно написать эквивалентный вызов `String.foo(str[, args])`:

* `String.cmp(s1, s2)` — аналог оператора сравнения s1 \<=\> s2.
* `str.empty()` — функциональная форма проверки на пустоту строки, равносильная условию `str == ""`.
* `str.startswith(prefix)` — возвращает истину, если строка начинается указанным префиксом. Имеются две перегрузки с аргументами типа `prefix: string` и `prefix: char`.
* `str.endswith(suffix)` — возвращает истину, если строка оканчивается указанным суффиксом. Аналогично имеются два перегруженных варианта.
* `str.find(substr)` — возвращает позицию первого найденного слева совпадения подстроки `substr` в строке `str`. Если совпадение не найдено, возвращается значение `-1`.
* `str.rfind(substr)` — аналогичен предыдущему, но ищет справа налево.
* `str.toupper()` — преобразует каждую букву строки в верхний регистр, например, `"Developers!".toupper()` =\> `"DEVELOPERS!"`.
* `str.tolower()` — преобразует каждую букву строки в нижний регистр.
* `str.lstrip()`, `str.rstrip()`, `str.strip()` — удаляют ведущие, замыкающие или одновременно обе группы пробельных символов соответственно. Пробельным считается обычный пробел, табуляция или символ конца строки.
* `str.tokens(f: char->bool)` — разбивает строку на список строк, отделяемых ограничителями. Ограничителем считается непрерывная последовательность символов, для которых функция f возвратила истинное значение:

```
val words = "Bill, Steve, Linus"
// создаёт список ["Bill", "Steve", "Linus"]
val word_list = words.tokens(fun (c) {c == ',' || c.isspace()})
```

* `str.replace(substr, new_substr)` — заменяет все неперекрывающиеся вхождения подстроки substr на новую подстроку new\_substr.
* `join_embrace(start, end, separator, string_list)` — строит строку, начиная с символа start, заканчивая символом end. Элементы списка вставляются между указанными границами и разделяются разделителем separator.
* `separator.join(string_list)` — упрощённый вариант предыдущей функции с пустой начальной и конечной частью.
* `str.to_int(), str.to_double()` — конвертируют строку в целое число или вещественное значение соответственно. Функция str.to\_int() поддерживает необязательные префиксы чисел: 0x (шестнадцатиричное представление), 0 и 0o (восьмиричное), 0b (двоичное). Поддерживаются произвольные десятичные цифры из набора Unicode (правосторонняя запись пока не поддерживается).
* `c.isalpha()`, `c.isdigit()`, `c.isspace()`, `c.isalnum()` возвращают истину, если символ является буквенным знаком Unicode, цифрой Unicode, пробелом Unicode или буквой/дигитом Unicode соответственно.
* `c.tolower()`, `c.toupper()` преобразуют буквы Unicode в нижний или верхний регистры соответственно. Остальные символы возвращаются неизменёнными.

## Регулярные выражения

Ficus оснащён двумя движками регулярных выражений. Первый из них — Re, включён в среду выполнения Ficus и доступен всегда. Второй движок — Re2, основанный на реализации Google [RE2](https://github.com/google/re2), обладает рядом расширенных возможностей. Для его использования необходимо заранее установить пакет RE2 вместе с сопутствующими заголовочными файлами.

Далее мы детально рассмотрим возможности движка Re (описание Re2 будет представлено позднее).

Данный движок использует алгоритм виртуальной машины Pike VM с временной сложностью O(N), что позволяет обрабатывать строку длиной N за линейное количество операций и фиксированное пространство (предполагается, что длина самого регулярного выражения намного короче длины строки).

Для работы с регулярными выражениями необходимо сначала импортировать модуль Re. Затем следует подготовить регулярное выражение путем его компиляции. Далее оно может быть использовано для полного сопоставления строки с шаблоном, частичного сопоставления начальных сегментов строки, поиска всех совпадающих подстрок или замены найденных подстрок новыми значениями, возможно, повторно задействуя части оригинального совпадения:

```
import Re
val re = Re.compile(r"[\w']+")
val text = "Hello, this is the first regexp test. Cool, isn't?"
print(re.findall_str(text)) # Предполагается, что выведутся все слова
```

Заметим, что здесь используется специальный литерал формата `r"..."`, позволяющий избежать удвоения каждого символа обратной косой черты.

Имеются следующие доступные функции и методы:

* `Re.compile(str)` — компилирует строку регулярного выражения в исполняемый байт-код. Полный перечень поддерживаемых регулярных выражений представлен ниже.
* `re.fullmatch(str, ignorecase=false, multiline=false)` — проверяет полное соответствие строки заданному регулярному выражению. Если установлено свойство ignorecase=true, сравнение становится нечувствительным к регистру символов как в тексте, так и в самом выражении. Установка флага multiline запрещает сопоставлять точку (.) и символ пространства (\\s) с переходом на новую строку.
* `re.prefixmatch(str, ignorecase=false, multiline=false): (int, int)[]?` — проверяет, совпадает ли начало строки с регулярным выражением. Возвращает `None`, если совпадение не обнаружено. В противном случае возвращает объект Some, содержащий массив пар целых чисел, каждая пара из которых задаёт полуоткрытый диапазон позиций \[startj, endj) для соответствующей группы совпадений. Группе 0 соответствует общее совпадение, группе 1 — первое вложенное выражение, заключённое в круглые скобки, и так далее.
* `re.prefixmatch_str(str, ignorecase=false, multiline=false): string []?` — альтернативная версия функции `prefixmatch`, возвращающая непосредственно подстроки, а не их диапазоны.
* `re.find(str, ignorecase=false, multiline=false): (int, int)[]?` — осуществляет поиск самой левой подстроки, соответствующей регулярному выражению. Возвращает `None`, если совпадений не найдено. В противном случае возвращает объект `Some`, содержащий массив пар целых чисел, каждая из которых описывает полуоткрытые диапазоны координат соответствующих групп совпадений.
* `re.find_str(str, ignorecase=false, multiline=false): string []?` — аналогична функции `find`, но возвращает сами подстроки, а не их координаты.
* `re.findall(str, ignorecase=false, multiline=false): (int, int)[,]` — находит все неперекрывающиеся подстроки, соответствующие регулярному выражению. Каждый ряд результирующей матрицы соответствует отдельному совпадению (количество рядов равно количеству найденных совпадений). Столбцы ряда содержат целые пары, аналогичные тем, что описаны в методах `prefixmatch` и `find`.
* `re.findall_str(str, ignorecase=false, multiline=false): string [,]` — аналогична функции `findall`, но возвращает сами подстроки.
* `re.replace(str, subst, ignorecase=false, multiline=false): string` — заменяет все неперекрывающиеся совпадения подстрокой `subst`, где в качестве заполнителей можно использовать маркеры вида `\0`, `\1` и т.д., позволяющие сохранить оригинальные совпадения. Например:

```
val digits = Re.compile(r"\d+")
// Получится "(123)-(456)"
val numbers_in_parens = digits.replace("123-456", "(\0)")
```

Поддерживаемые регулярные выражения образуют удобный подмножества популярных форматов Python и некоторых распространённых движков регулярных выражений:

* `\a`, `\d,` `\w`, `\s`, `\S` — соответствуют популярным классам символов: буква Unicode, цифра Unicode, идентификатор (буква, цифра или подчёркивание `_`), пробельный символ Unicode и непробельный символ Unicode соответственно. В многострочном режиме `\s` не совпадает с переводом строки.
* `.` — соответствует любому символу. В многострочном режиме не совпадает с символом перехода на новую строку (`\n`, `\r`).
* `\n`, `\r`, `\t` — соответствуют символам с кодами ASCII 10, 13 и 9 соответственно.
* `\b` — соответствует нулевой длине строки таким образом, что слева находится символ \\w, а справа — символ, отличный от \\w, или наоборот. Используется для обозначения границы слова.
* `\xXX`, `\ooo`, `\uxxxx`, `\Uxxxxxxxx` — соответствуют символу, заданному шестнадцатеричным или восьмеричным кодом.
* `\\`, `\[`, `\]`, `\(`, `\)`, `\.`, `\?`, `\+`, `\-`, `\*`, `\|`, `\"` — соответствуют символу, следующему за `\`.
* `c`, где `c` отличается от `\`, `|`, `[`, `]`, `(`, `)`, `.`, `*`, `+`, `?`, `"` — соответствует самому себе.
* `[c1-c2c3-c4c5c6-c7]` — диапазон символов, включающих интервалы от `c1` до `c2`, от `c3` до `c4`, символ `c5` и диапазон от `c6` до `c7`. Могут использоваться классы символов.
* `[^c1-c2c3-c4c5c6-c7]` — символ, не принадлежащий указанным диапазонам.
* `regexp?` — ноль или одно совпадение с `regexp`. Поиск идёт по наибольшему возможному соответствию.
* `regexp??` — ноль или одно совпадение с `regexp`. Поиск останавливается на первом минимальном результате.
* `regexp*` — любое количество совпадений с regexp, включая отсутствие. Поиск максимизирует количество найденных совпадений.
* `regexp*?` — минимальное количество совпадений с `regexp`, включая отсутствие.
* `regexp+` — одно или больше совпадений с `regexp`. Максимальная цепочка совпадений.
* `regexp+?` — минимум одно совпадение с `regexp`. Минимальная цепочка совпадений.
* `regexp1|regexp2|regexp3|...` — любая из предложенных альтернатив. Поиск пытается выбрать наибольшее возможное совпадение.
* `(regexp)` — захватывающее скобочное выражение, запоминающее положение соответствующей группы в целом выражении.
* `(?:regexp)` — неназываемое скобочное выражение, не сохраняющее положения группы.
* `\0` — заполнитель всего соответствующего регулярного выражения.
* `\1`, `\2`, &ellips;, `\9` — заполняют подгруппы `1`—`9` регулярного выражения.

# Обобщённое программирование

Значительная доля современного программирования связана с созданием универсальных компонентов, позволяющих избежать многократного написания одних и тех же базисных элементов при работе над схожими проектами. Иногда полезный алгоритм или структура данных разрабатывается для конкретного случая, однако впоследствии оказывается необходимым применить его к данным другого типа, например, сортировка может применяться как к числам, так и к строкам или кортежам, при наличии способа сравнить элементы друг с другом. Ранее мы рассмотрели несколько полезных алгоритмов, представленных примерами, таких как функция вычисления производных `make_deriv: (double->double, double)->(double->double)`. Было бы удобно иметь способ выразить подобные алгоритмы обобщённо, позволяя легко адаптировать их к другим типам данных. Подобно многим современным языкам программирования, таким как C\+\+, C#, OCaml и др., Ficus обеспечивает механизмы реализации обобщённых алгоритмов и типов данных, известных как параметрический полиморфизм.

Начнём с обобщённых функций. Создание обобщённой функции достаточно простое — достаточно заменить один или несколько аргументов типом, обозначаемым специальной меткой `'идентификатор`, который воспринимается как **переменная типа**, принимающая любые конкретные типы значений. Нет необходимости делать весь тип аргумента параметром, его можно использовать в качестве составной части сложного спецификатора типа. Рассмотрим пример создания обобщённого варианта функции make\_deriv() и её применения:

```
fun make_deriv(f: 't->'t, delta: 't)
{
    // обратите внимание, внутренняя функция не является обобщённой,
    // она использует тот же тип 't,
    // следовательно, её тип полностью определяется при инстанцировании внешней функции, например, с 't=float
    fun (x: 't) { (f(x + delta) - f(x - delta))/(delta*2) }
}
// создадим производную от sin(float->float)
val d_fsin = make_deriv(sin, 0.001f)
for i <- 0:10 {
    val x = i/3.f
    val err = abs(d_fsin(x) - cos(x))
    println(f"{x}: абсолютная ошибка аппроксимации производной={err}")
}
```

Обобщённые функции используются точно так же, как обычные. Реализуем ещё несколько примеров обобщённых обработчиков массивов:

```
// находим максимум пикселей в окрестности 3x3 вокруг каждого элемента.
// эта операция применима к изображениям любого типа, при условии доступности функции max()
fun dilate3x3(img: 'pix [,]): 'pix [,]
{
    val (h, w) = size(img)
    [for y <- 0:h for x <- 0:w {
        val a = max(img.clip[y-1,x-1],
          max(img.clip[y-1,x], img.clip[y-1, x+1]))
        val a = max(a, max(img.clip[y,x-1],
          max(img.[y,x], img.clip[y, x+1])))
        max(a, max(img.clip[y+1,x-1],
          max(img.clip[y+1,x]), img.clip[y+1, x+1])))
    }]
}

// умножаем матрицу А на транспонированную матрицу В и прибавляем матрицу С
fun gemm_A_Bt_plusC(A: 't [,], B: 't [,], C: 't [,])
{
    val (ma, na) = size(A)
    val (mb, nb) = size(B)
    val (mc, nc) = size(C)
    [for i <- 0:mc for j <- 0:nc {
        fold s = C[i, j] for k <- 0:na {s + A[i, k]*B[j, k]}
    }]
}

// явная специализация обобщённой функции проста
val dilate3x3_32f = (dilate3x3 : float [,] -> float [,])
val rng = RNG(123u64)
dilate3x3_32f(random(rng, (30, 30), 0.f, 1.f))
```

Создание и использование сложных обобщённых типов столь же просты, как показано далее в разделе Суммарные типы или варианты.

Так же просто создаются и используются обобщенные типы, см. например [Тип-сумма или вариант]()

## Специальные аргументы в обобщённых функциях

### 't \[\+\]

Вы могли заметить, что конструкция обхода массивов различной размерности часто выглядит одинаково, например, реализация поэлементного суммирования двух массивов выглядит следующим образом независимо от типа элементов и размерности массивов (лишь бы они были одинаковыми у обоих массивов):

```
val result = [for x <- A, y <- B {x + y}]
```

Ficus предоставляет удобную конструкцию для реализации единой обобщённой функции, работающей с массивами любой размерности:

```
operator .+ (A: 't [+], B: 't [+]) = [for x <- A, y <- B {x+y}]
```

То есть вместо задания множества аналогичных функций с параметрами разных размерностей ('t \[\], 't \[,\], 't \[,,\] и т.д.) мы используем единый шаблон 't \[\+\]. Для каждой конкретной размерности (одномерной, двумерной и т.д.) и каждого конкретного типа элементов компилятор создаст отдельную специализированную версию функции, подходящую именно для таких массивов.

### (...)

Стандартная библиотека Ficus также предлагает богатый набор операций над кортежами, многие из которых поддерживают кортежи произвольной длины. Благодаря цилу `for` по кортежам, генерации кортежей (tuple comprehension) и обозначению `(...)` сам код остаётся компактным.

```
operator .> (a: (...), b: (...)) = (for x <- a, y <- b {x > y})
```

`(...)` обозначает мета-тип, соответствующий кортежу произвольной длины и состава. Конструкция `for` внутри круглых скобок реализует цикл, формирующий новый кортеж, элементами которого являются результаты тела цикла. Типы элементов могут различаться, а значит, тело цикла может варьироваться от одной итерации к другой. Компилятор не создает реальный цикл, а разворачивает его полностью, компилируя каждую итерацию отдельно, после чего итоговый кортеж строится из полученных результатов.

Если вы хотите ограничить кортежи однородными элементами одного типа, можно использовать обозначение `(T...)`, где `T` — это тип переменной (`'elemtype` или подобный) или конкретный тип, например, `float` (то есть `(float ...)` обозначает кортеж, состоящий исключительно из вещественных чисел).

```
fun dot(a: ('t ...), b: ('t ...)) =
    // аккумулятор принимает тип double для вещественных величин,
    // float — для остальных случаев
    fold s = (0:>'t)*0.f for x<-a, y<-b {s + x*y}
```

Стоит отметить, что цикл по кортежу можно поместить внутрь квадратных скобок `[]`, чтобы превратить результаты трансформации кортежа в список.

### \{...\}

Операций над записями значительно меньше, но всё равно возможна реализация обобщённых функций, работающих с любыми записями. Цикл по полю записи тоже возможен. Конструировать записи по результатам невозможно, но итоговая обработка полей записи может быть превращена в кортеж или список:

```
// часть файла Builtins.fx
// цикл по записи выдаёт имена членов записи и их значения
fun string(r: {...}) = join_embrace("{", "}", ", ", [for (n, x) <- r {n + "=" + repr(x)}])
```