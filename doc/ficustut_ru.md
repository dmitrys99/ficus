
# Введение

Ficus -- функциональный язык программирования, поддерживающий императивную и объектно-ориентированную парадигмы программирования. Основная область применения языка Ficus -- вычисления. В языке есть полноценная поддержка многомерных массивов, они могут эффективно обрабатываться в один или несколько потоков. Компилятор Ficus преобразует исхоные файлы .fx и генерирует переносимый код на C/C++. Созданный код хорошо совместим с C и C ++ в обоих направлениях: удобно вызывать код C/C++ из Ficus, также как и вызывать код на C, сгенерированный компилятором Ficus, из пользовательских приложений.

Этот документ дает краткое и, надеюсь, исчерпывающее введение в синтаксис и семантику языка и позволит вам начать с ним работать. Предполагается некоторое базовое знание C/C++ или других языков программирования (C#, Java, Javascript, Python, F#, OCaml, ...), поскольку многие концепции похожи и, вероятно, описаны не очень подробно.

# Лицензия

Ficus -- проект с открытым исходным кодом. Компилятор, среда исполнения и стандартная библиотека распространяются под лицензией Apache 2.

# Установка

Компилятор Ficus реализован на Ficus. Предварительно сгенерированные исходные тексты `.c` ранее созданной версии компилятора поставляются вместе с дистрибутивом. Поэтому процесс сборки довольно прост:

1. Первоначальная версия компилятора собирается из сохраненных исходных текстов на C (обозначим ее как `ficus0`).
2. Следом из исходных текстов `.fx` собирается свежий компилятор (`ficus`).

Для запуска процедуры раскрутки (bootstrap) достаточно иметь работающий C/C++ компилятор и утилиту make.

## В Unix-подобных системах (Linux, Mac OS, BSD и др.)

1. Клонируете репозиторий:

 ```
$ cd ~/myprojects # в какой-то из ваших папок с проектами
$ git clone https://github.com/vpisarev/ficus.git
 ```

2. Переходите в каталог Ficus и собираете компилятор Ficus с именем `ficus`:

 ```
 $ cd ficus
 $ make -j8 # создаете ficus0, затем ficus
 $ bin/ficus -run test/test_all.fx # запускаете тесты, чтобы удостовериться
                                   # что собранный компилятор работает
 ```

3. Настраиваете переменные окружения, чтобы командная оболочка знала, где найти Ficus (чтобы `ficus` можно было запускать без явного указания пути).

 ```
 $ export PATH=~/myprojects/ficus/bin:$PATH
 $ export FICUS_PATH=~/myprojects/ficus/lib # путь поиска стандартной библиотеки
 ```

Примечание: Если исполняемый файл `ficus` и библиотека находятся рядом в определенных местах, компилятор Ficus автоматически обнаруживает стандартную библиотеку. Если же переменная `FICUS_PATH` задана, например, в `.bash_profile` или аналогичном месте, исполняемый файл `ficus` можно переносить в любое место и запускать оттуда.

## Windows

TBD

## Использование

После установки Ficus можно запустить примеры из `ficus/examples` и попробовать написать свою программу.
Самая простая и известная программа, конечно, *Hello, world!*. Откройте текстовый редактор и введите:

```
println("Hello, world!")
```

Сохраните в файле `helloworld.fx`, затем запустите его с помощью команды

```
$ ./bin/ficus -run helloworld.fx
```

Программа поприветствует мир. В той же директории, куда вы поместили `helloworld.fx` появится поддиректория `__fxbuild__/helloworld/` с несколькими файлами `*.c`, включая `helloworld.c`. Это результат работы компилятора. Кроме того, там же находятся файлы приложений `helloworld` (на Unix) или `helloworld.exe` (на Windows).

Можно собрать приложение и запустить его отдельными действиями:

```
$ ./bin/ficus -app helloworld.fx
$ ./__fxbuild__/helloworld/helloworld
```

Вы уже видели опции компилятора `-app` и `-run`,  они указывают компилятору собрать и запустить приложение соответственно. Весь список опций можно получить, запустив 

```
$ ficus -h
```

Подробности пожно посмотреть в [Приложении А](#appendix-a.-using-ficus) в конце этого документа.

Хорошо, давайте посмотрим, как писать программы на Ficus.

Программа на Ficus состоит из одного или нескольких файлов с расширением `.fx`, называемых модулями. Модуль может импортировать другие модули и/или может импортироваться из других модулей, см. раздел [Модули](#modules). Модули представляют собой текстовые файлы в кодировке UTF-8, содержащие последовательность (возможно рекурсивную) деклараций, директив и выражений. Где это не привнесет неясности, для краткости будем называть все перечисленное выражениями. Набор выражений разделяется `;` или переводом каретки (LF/CR/CRLF). Выражения могут занимать несколько строк. В большинстве случаев Ficus автоматически отделяет одно выражение от другого, но иногда могут потребоваться явное добавление точки с запятой или круглых скобок.

С точки зрения компилятора выражения это последовательность токенов. Токенами являются операторы, идентификаторы, ключевые слова, литералы и пр. Отступы и пробелы в почти не имеют значения для компилятора. Оформляйте код, как вам нравится. Например, следующиий фрагмент кода плохо оформлен, но это все ещё корректный код:

  ```
  if a>b {
     a
  }else {println("b победил"); b}
  ```

Пробел между `a` и `>`, `>` и `b`, `}` и `else` не обязателен, но можно и поставить. Но пробел(ы) требуется, чтобы отделить `a` от `if`.  Также для отделения `println(...)` от `b` требуется `;`, поскольку два последовательных выражения в рамках одного блока расположены на одной строке.

В Ficus *пробел* это пробельный символ (`' '`, ASCII `0x20`), табуляция (ASCII `0x09`), перевод каретки (LF/CR/CRLF), комментарий или любая комбинация всего перечисленного.

Комментарии бывают двух типов:

1. Блочный комментарий, ограниченный строками `/*` и `*/`. Такие комментарии могут располагаться в любом месте между токенами, могут занимать одну и более строчек и могут быть вложенными.

```
  /* Комментируем вообще всё
  /*
    Ищем максимум a и b
     a и b
  */
  if a > b /* давайте сравним */ {a} else {b /*b>=a*/}
  */
  ```

2. Однострочные комментарии, начинающиеся с `//` и продолжающиеся до конца строки

  ```
  if a > b {
     a // a победитель
  } else {
     // b победитель,
     // и мы об этом сообщаем
     println("b победитель")
     b // println() и b разделены переводом каретки
  }
  ```

Как выше сказано, иногда перевод каретки может трактоваться как конец одного выражения и начало следущего, хотя предполагалось обратное.
Типичные ситуации:

