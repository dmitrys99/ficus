
# Введение

Ficus &ndash; функциональный язык программирования, поддерживающий императивную и объектно-ориентированную парадигмы программирования. Основная область применения языка Ficus -- вычисления. В языке есть полноценная поддержка многомерных массивов, они могут эффективно обрабатываться в один или несколько потоков. Компилятор Ficus преобразует исхоные файлы .fx и генерирует переносимый код на C/C++. Созданный код хорошо совместим с C и C ++ в обоих направлениях: удобно вызывать код C/C++ из Ficus, также как и вызывать код на C, сгенерированный компилятором Ficus, из пользовательских приложений.

Этот документ дает краткое и, надеюсь, исчерпывающее введение в синтаксис и семантику языка и позволит вам начать с ним работать. Предполагается некоторое базовое знание C/C++ или других языков программирования (C#, Java, Javascript, Python, F#, OCaml, ...), поскольку многие концепции похожи и, вероятно, описаны не очень подробно.

# Лицензия

Ficus -- проект с открытым исходным кодом. Компилятор, среда исполнения и стандартная библиотека распространяются под лицензией Apache 2.

# Установка

Компилятор Ficus реализован на Ficus. Предварительно сгенерированные исходные тексты `.c` ранее созданной версии компилятора поставляются вместе с дистрибутивом. Поэтому процесс сборки довольно прост:

1. Первоначальная версия компилятора собирается из сохраненных исходных текстов на C (обозначим ее как `ficus0`).
2. Следом из исходных текстов `.fx` собирается свежий компилятор (`ficus`).

Для запуска процедуры раскрутки (bootstrap) достаточно иметь работающий C/C++ компилятор и утилиту make.

## В Unix-подобных системах (Linux, Mac OS, BSD и др.)

1. Клонируете репозиторий:

 ```
$ cd ~/myprojects # в какой-то из ваших папок с проектами
$ git clone https://github.com/vpisarev/ficus.git
 ```

2. Переходите в каталог Ficus и собираете компилятор Ficus с именем `ficus`:

 ```
 $ cd ficus
 $ make -j8 # создаете ficus0, затем ficus
 $ bin/ficus -run test/test_all.fx # запускаете тесты, чтобы удостовериться
                                   # что собранный компилятор работает
 ```

3. Настраиваете переменные окружения, чтобы командная оболочка знала, где найти Ficus (чтобы `ficus` можно было запускать без явного указания пути).

 ```
 $ export PATH=~/myprojects/ficus/bin:$PATH
 $ export FICUS_PATH=~/myprojects/ficus/lib # путь поиска стандартной библиотеки
 ```

Примечание: Если исполняемый файл `ficus` и библиотека находятся рядом в определенных местах, компилятор Ficus автоматически обнаруживает стандартную библиотеку. Если же переменная `FICUS_PATH` задана, например, в `.bash_profile` или аналогичном месте, исполняемый файл `ficus` можно переносить в любое место и запускать оттуда.

## Windows

TBD

## Использование

После установки Ficus можно запустить примеры из `ficus/examples` и попробовать написать свою программу.
Самая простая и известная программа, конечно, *Hello, world!*. Откройте текстовый редактор и введите:

```
println("Hello, world!")
```

Сохраните в файле `helloworld.fx`, затем запустите его с помощью команды

```
$ ./bin/ficus -run helloworld.fx
```

Программа поприветствует мир. В той же директории, куда вы поместили `helloworld.fx` появится поддиректория `__fxbuild__/helloworld/` с несколькими файлами `*.c`, включая `helloworld.c`. Это результат работы компилятора. Кроме того, там же находятся файлы приложений `helloworld` (на Unix) или `helloworld.exe` (на Windows).

Можно собрать приложение и запустить его отдельными действиями:

```
$ ./bin/ficus -app helloworld.fx
$ ./__fxbuild__/helloworld/helloworld
```

Вы уже видели опции компилятора `-app` и `-run`,  они указывают компилятору собрать и запустить приложение соответственно. Весь список опций можно получить, запустив 

```
$ ficus -h
```

Подробности пожно посмотреть в [Приложении А](#appendix-a.-using-ficus) в конце этого документа.

Хорошо, давайте посмотрим, как писать программы на Ficus.

Программа на Ficus состоит из одного или нескольких файлов с расширением `.fx`, называемых модулями. Модуль может импортировать другие модули и/или может импортироваться из других модулей, см. раздел [Модули](#modules). Модули представляют собой текстовые файлы в кодировке UTF-8, содержащие последовательность (возможно рекурсивную) деклараций, директив и выражений. Где это не привнесет неясности, для краткости будем называть все перечисленное выражениями. Набор выражений разделяется `;` или переводом каретки (LF/CR/CRLF). Выражения могут занимать несколько строк. В большинстве случаев Ficus автоматически отделяет одно выражение от другого, но иногда могут потребоваться явное добавление точки с запятой или круглых скобок.

С точки зрения компилятора выражения это последовательность токенов. Токенами являются операторы, идентификаторы, ключевые слова, литералы и пр. Отступы и пробелы в почти не имеют значения для компилятора. Оформляйте код, как вам нравится. Например, следующиий фрагмент кода плохо оформлен, но это все ещё корректный код:

  ```
  if a>b {
     a
  }else {println("b победил"); b}
  ```

Пробел между `a` и `>`, `>` и `b`, `}` и `else` не обязателен, но можно и поставить. Но пробел(ы) требуется, чтобы отделить `a` от `if`.  Также для отделения `println(...)` от `b` требуется `;`, поскольку два последовательных выражения в рамках одного блока расположены на одной строке.

В Ficus *пробел* это пробельный символ (`' '`, ASCII `0x20`), табуляция (ASCII `0x09`), перевод каретки (LF/CR/CRLF), комментарий или любая комбинация всего перечисленного.

Комментарии бывают двух типов:

1. Блочный комментарий, ограниченный строками `/*` и `*/`. Такие комментарии могут располагаться в любом месте между токенами, могут занимать одну и более строчек и могут быть вложенными.

```
  /* Комментируем вообще всё
  /*
    Ищем максимум a и b
     a и b
  */
  if a > b /* давайте сравним */ {a} else {b /*b>=a*/}
  */
  ```

2. Однострочные комментарии, начинающиеся с `//` и продолжающиеся до конца строки

  ```
  if a > b {
     a // a победитель
  } else {
     // b победитель,
     // и мы об этом сообщаем
     println("b победитель")
     b // println() и b разделены переводом каретки
  }
  ```

Как выше сказано, иногда перевод каретки может трактоваться как конец одного выражения и начало следущего, хотя предполагалось обратное.
Типичные ситуации:

1. перенос строки перед бинарным оператором трактует последний как унарный оператор, например `+`, `-` или`*`:

   ```
   val diff =  a
             - b
   ```

трактуется как `val diff = a; -b`, что, скорее всего, не то, что ожидалось. В большинстве таких случаев компилятор выдаст сообщение об ошибке, встретив не-void выражение в середине блока кода. Правильный способ переноса таких выражений на несколько строк: 

   ```
   val diff = a -
              b
   ```

   или

   ```
   val diff = (a   // включение выражения в скобки указывает, что мы задали единое выражение
               -b)
   ```

   Можно поискать подозрительные места в коде по регулярному выражению `^\s+[+-*]`.

2. перенос строки перед открывающей круглой скобкой `(` при вызове фукнции:

    ```
    foo
    (
       x,
       y
    )
    ```
    Такой код будет трактован как `foo; (x, y)`, где первое выражение вернет функцию `foo`, второе создаст пару `(x, y)`. В этом случае компилятор также сообщит о не-void выражении `foo` в середине блока кода. Для исправления достаточно прижать `(` к имени функции:
    ```
    foo(
          x,
          y
      )
    ```

    или

    ```
    foo(x, y)
    ```

4. перенос строки перед открывающей квадратной скобкой `[` при доступе к массиву или индексируемой коллекции:

    ```
    mymatrix
        [
           i,
           j
        ]
    ```

   Как и в случае с функцией, код будет трактован как `mymatrix; [i, j]`, где первое выражение вернет матрицу `mymatrix`, а второе создаст список из двух элементов `[x, y]`. Компилятор и здесь укажет на ошибку. Поместите `[` на ту же строку, что и `mymatrix`, это исправит ситуацию:

    ```
    mymatrix[
          i,
          j
      ]
    ```

    или

    ```
    mymatrix[i, j]
    ```

## Токены

В Ficus используются следующие типы токенов:

* **литералы**, представляющие разнообразные скалярные значения:

  * 8-, 16-, 32- или 64-битные, знаковые или беззнаковые целые (литералы типов `int8`, `uint8`, `int16`, `uint16`, `int32`, `uint32`, `int`, `uint64`, `int64` cсоответственно), 16-, 32- или 64-битные числа с плавающей точкой (типов `half`, `float` и `double` соответственно):

    ```
    42         // десятичное число
    0xffu8     // 8-битное беззнаковое число в шестнадцатеричной нотации

    12345678987654321i64 // 64-битное целое,
               // суффикс i... обозначает литерал n-битного знакового целого
               // суффикс u... обозначает литерал n-битного беззнакового целого

    0777       // восьмеричное число
    0b11110000 // целое в двоичной нотации
    3.14       // число с плавающей точкой двойной точности
    1e-5f      // число с плавающей точкой одинарной точности 
               // в экспоненциальной нотации
    0.25h      // 16-битное число с плавющей точкой
               // (пока такие числа реально в Ficus не поддерживаются)
    nan        // особый литерал 'not a number' (не число) двойной точности
               // добавление суффикса 'f' дает 'nan' одинарной точности
    -inff      // литерал '-infinity' (минус бесконечность) одинарной точности
               // удаление суффикса 'f' дает значение двойной точности.
    ```

  * логические значения (типа `bool`)

    ```
    true
    false
    ```

  * текстовые строки (типа `string`)

    ```
    "abc"
    "hello, world!\n" //  поддерживаются обычные ESC-последовательности в стиле C

    /*
      Не-ASCII символы корректно разбираются из
      UTF-8 и затем сохраняются и обрабатываются
      как Unicode (4-байтные) символы.
      Код ниже выведет 9
    */
    println(length("привет! \U0001F60A"))

    /*
      Возможно включение произвольных символов
      с помощью ASCII или Unicode значений:
      \ooo       — 1-3-разрядный восьмеричный ASCII код,
      \xXX       — 2-разрядный шестнадцатеричный ASCII код,
      \uXXXX     — 4-разрядный шестнадцатеричный Unicode код,
      \UXXXXXXXX — 8-разрядный шестнадцатеричный Unicode код,
    */
    "Hola \U0001F60A"

    // Similar to Python, f-strings may embed expression values using {} string interpolation construction
    // Как и в Python, внутри f-строки с помощью интерполяции {} можно использовать значения
    val r = 10
    println(f"площадь окружности радиуса R={r} составляет={3.1415926*r*r}")
    // строка выше преобразуется парсером в 
    println("площадь окружности радиуса R=" + string(r) +
           " составляет=" + string(3.1415926*r*r))

    // поэтому пользовательские объекты также можно интерполировать,
    // предоставляя для них функцию string():
    type point = { x: int; y: int }

    // дабы избежать путаницы, литералы '{' and '}'
    // в f-строке необходимо продублировать
    fun string(p: point) = f"{{x={p.x}, y={p.y}}}"
    val pt = point { x=10, y=5 }
    println(f"pt={pt}")

    // Возможно использование многострочных строковых литералов.
    // По умолчанию символы конца строки в сгенерированной строке сохраняются.
    // \r\n заменяются на \n для кросс-платформенной совместимости.
    val author="anonymous"
    f"многострочные
      строковые 
        литералы
      ограничены
     кавычками, как обычные строковые литералы
       и могут включать в себя значения
            {author}
    "
    
    // Добавьте \ перед концом строки,
    // чтобы удалить его и последующие пробелы из литерала
    val errmsg = "Очень длинное и \
       детализированное сообщение об ошибке, \
       описывающее, что же пошло не так."

    // r-строки в основном используются для регулярных выражений,
    // поскольку в них можно указывать символьные классы
    // и другие спецсимволы без дублирования '\'
    val assigment_regexp = Re.compile(
      r"(?:val|var)\s+([\a_]\w+)\s*=\s*(\d+|\w+)")
    ```

  * символы (типа `char`) — то, из чего сделаны текстовые строки. Символьные литералы выглядять также как односимвольные текстовые литералы, включенные в одиночные кавычки.

    ```
    chr(ord('A')) == 'A' // ~ true
    ```

  * полиморфные литералы — пустой список, вектор или 1-, 2- и более мерные массивы (типов `'t list`, `'t vector`, `t []`, `t [,]` и пр. соответственно)

    ```
    []
    ```

  * нулевой указатель null (смотри секцию взаимодействия с C/C++)

    ```
    null
    ```

* **идентификаторы** — определяют все именованные сущности, встроенные или определенные, в коде: значения, переменные, функции, типы, исключения, вариантные теги и др. Идентификатор начинается с подчеркивания `_` или буквы (латинской или нет) и содержит 0 и более последовательных подчеркиваний, букв или десятичных цифр, т.е. идентификатор может быть определен регулярным выражением `[\a_]\w+`. Идентификатор `_` имеет особое значение, он определяет неиспользуемый параметр функции или, в общем случае, элемент шаблона, который пользователь проигнорировал (шаблоны обсуждаются далее в этом документе).

* **ключевые слова** — выглядят как идентификаторы и используются для формирования синтаксических конструкций. Нельзя использовать идентификатор с тем же именем, что и ключевое слово.

Список ключевых слов Ficus:

  ```
  as break catch class continue do else exception
  false finally fold for from fun if import inf inff
  interface match nan nanf null operator ref return throw
  true try type val var when while
  ```

  Также есть **атрибуты**, начинающиеся с `@`. Они используются для задания свойств определяемых символов, циклов, блоков кода и др. 

  Перечень атрибутов:

  ```
  @ccode @data @inline @nothrow @pragma
  @parallel @private @pure @sync @text @unzip
  ```

  Имена стандартных типов трактуются как ключевые слова:

  ```
  int8 uint8 int16 uint16 int32 uint32 int uint64 int64
  half float double bool string char list vector cptr exn
  ```

  Важно заметить, что можно определить функцию или значение с названием, совпадающем со стандартными типами данных. В частности, общей практикой является присвоение имен целевых типов для фукнций преобразования типов:


  ```
  fun string(set: 't Set.t) =
    join_embrace("{", "}", ", ", set.map(repr))
  type ratio_t = {n: int; d: int}
  fun double(r: ratio_t) = double(r.n)/r.d
  ```

* **операторы**

  Есть некоторое количество унарных и бинарных операторов:

  **бинарные**:

  ```
  // переопределяемые бинарные операторы
  + − * / % **
  .+ .- .* ./ .**
  == != > < <= >= <=> ===
  .== .!= .> .< .<= .>= .<=>
  & | ^ >> << \

  // другие бинарные операторы
  .{...}

  = += −= *= /= %= &= |= ^= >>= <<=
  .={...}

  && || :: :>
  ```

  **унарные**

  ```
  // переопределяемые префиксные операторы
  ~
  // другие префиксные операторы
  + − *
  .- ! \

  // переопределяемые постфиксные операторы
  '
  ```

  Переопределяемые операторы можно заключить в скобки `()` и использовать как идентификаторы, например для передачи в функцию. Еще такие операторы можно переопределять с помощью ключевого слова `operator`:

  ```
  type ratio = { n: int; d: int }
  operator < (r1: ratio, r2: ratio) {
    val scale = r1.d*r2.d
    if scale > 0 {r1.n*r2.d < r2.n*r1.d}
    else {r1.n*r2.d > r2.n*r1.d}
  }
  fun R(n: int, d: int) = ratio {n=n, d=d}
  val sorted = [R(1,2), R(3,5), R(2,3)].sort((<))
  ```

* Есть также **разделители** и **скобки**

  ```
  -> => <- @ . , : ; [ ] ( ) { }
  ```

Операторы будут подробно разъяснены позже в этом руководстве.

Далее посмотрим как из токенов составляются конструкции языка.

# Значения и переменные

Как сказано ранее, исходный текст на Ficus это последовательность *выражений*, опделяемых собственно выражениями, объявлениями и директивами. Директивы используются для импорта модулей (описывается в секции *Модули*) и для настройки компилятора через прагмы.
Объявления вводят новые именованные сущности:
* значения и переменные
* функции
* типы, в том числе классы
* интерфейсы
* исключения

Значения и переменные &ndash; это именованные сущности, связывающие некоторые данные с именами, которые можно использовать для передачи данных в обрабатывающие алгоритмы и возвращать из них. Чем они значения отличаются от переменных?

* Значения присваиваются ровно один раз во время объявления и затем их нельзя изменить.
* Переменные могут получить новое значение после того, как были инициализированы.

В большинстве языков поддерживаются и значения, и переменные, но в императивных языках используются преимущественно переменные, тогда как в функциональных языках преобладает использование значений. Ficus поддерживает и функциональный, и императивный стили разработки, но все же это больше функциональный язык, так что использование значений поощряется. Например, в компиляторе Ficus, реализованном на Ficus, примерно 4500 объявлений значений и всего около 450 объявлений переменных. Переменные используются в 10 раз реже, чем значения.

Объявления значений и переменных выглядят похоже:

```
val <имя_значения> [ : <необязательное указание типа>] = <выражение>
var <имя_переменной> [ : <необязательное указание типа>] = <выражение>
```

Значения можно считывать, переменные можно считывать и изменять. В большинстве случаев тип значения и переменной выводится, но иногда требуется указать тип явно:

```
val a = 5
var b = "abc"
val c = a + 1, d = string(c) // задается два значения

// ошибка: каждое значение или переменная 
// должны явно быть проинициализированы
var x : float;

b += "def"                    // b становится "abcdef"
b = 3.14                      // ошибка: переменная может поменять
                              // значение, но не тип
a = c + 2                     // ошибка: значения нельзя повторно присвоить
var curr_list : int list = [] // явно указываем, что
                              // задается пустой список целых чисел
curr_list = 5 :: curr_list    // добавляем 5 в начало списка
```

Пользователи C/C++ могу воспринимать значения как `const`-переменные, концепции очень похоже. Но есть одно важно отличие. Значения нельзя переприсвоить, но если в них содержится мутируемы объект, например массив, то можно изменять части объекта, в случае массива &ndash; его элементы:

```
val m3x3 = array((3, 3), 1.f) // создается матрица 3x3 чисел с плавающей точкой,
                              // заполненная единицами.
m3x3[0, 0] = 0.f              // заменяем.левый верхний элемент нулем
m3x3[:,:] = m3x3 * m3x3       // заменяем всю матрицу 
                              // квадратами значений
m3x3 = m3x3 * m3x3            // ошибка: нельзя переприсвоить значение
```

Можно спросить, зачем использовать значения, когда переменные объявляются почти также и мощнее?

Компилятору значительно проще оптимизировать код со значенимя, чем с переменными, сторонним библиотекам анализа кода значительно проще проверять такой кода. Кроме того, общая практика показывает, что функциональный код с неизменяемыми значениями содержит меньше побочных эффектов и проще в отладке в сравнении с императивным кодом, практически из побочных эффектов и состоящего.

Много ли можно сделать, используя лишь значения? Теория (лямбда-исчисление) говорит, что произвольно сложный алгоритм можно реализовать используя рекурсию, неизменяемые структуры и значения. Например, вот как можно получить первые `n` чисел Фибоначчи без использования переменных:

```
fun fibseq(n: int)
{
    fun fib_(i: int, a: int, b: int, n: int, result: int list) =
       if i < n {
           fib_(i+1, a+b, a, b::result)
       } else {
           result.rev()
       }
    fib_(0, 1, 1, n, [])
}
println(fibseq(30))
```

## Переиспользование имен значений

Бывают ситуации, когда значение вычисляется путем сложных расчетов, так что вместо одного очень сложного выражения оно вычисляется по шагам:

```
val a0 = compute_initial_a()
val a1 = if a0<0 {foo(a0)} else {a0}
val a2 = bar(a1)
val a3 = baz(a2)
...
```

Код плохо выглядит и тяготеет к ошибкам, поскольку можно случайно ошибиться и написать `a1` вместо `a2` в определении `a3`. Чтобы справиться с этим, Ficus позволяет многократно использовать одно имя:

```
val a = compute_initial_a()
val a = foo(a)
val a = bar(a)
val a = baz(a)
...
```

Выглядит это так, будто `a` &ndash; переменная, однако компилятор неявно создает новое имя для каждого появления `a`, то есть после фазы вывода типов код будет выглядеть примерно так: 

```
val a_1234 = compute_initial_a_780()
val a_1235 = foo_542(a_1234)
val a_1236 = bar_601(a_1235)
val a_1237 = baz_927(a_1336)
...
```

## Распаковка структура при определении значений

Можно определить сразу несколько значений, если развернуть н-ку, запись или единственный вариант. Все эти структуры, равно как и *сопоставление с образцом* обсуждаются далее, сейчас же представим простейшую и наиболее часто используемую форму такой конструкции:

```
val /* или var */ (x1, x2, ..., xn) = expr
```

Вместо любого `xj` можно подставить `_`, если какое-то из значений не нужно. Распаковка может быть вложенной:

```
// переопределяем a как min(a, b)
// и одновременно b как  max(a, b)
val (a, b) = (min(a, b), max(a, b))
val person_info = ("Joe", "male", 180, 75, (1980, 5, 1))
val (name, gender, height, weight, (year, _, _)) = person_info
```

# Выражения

В Ficus можно пользоваться обычным набором арифметических выражений. Кроме того, поскольку это фукнциональный язык, многие управляющие конструкции, выполненные как операторы в императивных языка, также являются выражениями и их можно использовать в других выражениях:
```
val rng = RNG(0x123u64)
println(if bool(rng) {"головы"} else {"хвосты"})
```
Обратите внимание, что `if` не является тернарной операцией, как в C/C++, это полноценный условный оператор, внутрь веток `then` и `else`которого можно вкладывать любое корректное выражение, включая определение значей и функций и пр.

Операции являются основой выражений. В таблице представлены операции, отсортированные по приоритетам (от низшего к высшему):

| Операция                 | Приоритет | Ассоциативность |       Тип результата      |     Описание                                    |
|:------------------------:|:---------:|:---------------:|:-------------------------:|:------------------------------------------------|
| `exp1 = exp2`            |       1   |       левая     |      `void`               |     присвоить новое значение                    |
| `exp1 op= exp2`          |       1   |       левая     |      `void`               |     дополненное выражение присваивания          |
| `exp1 : typespec`        |       2   |       N/A       |    `typespec`             |     аннотация типа                              |
| `exp1 :> typespec`       |       2   |       левая     |    `typespec`             |     приведение типа                             |
| `exp1 : exp2 : exp3`     |       2   |       левая     |    диапазон               |     построение диапазона                        |
| `exp1 : exp2`            |       2   |       левая     |    диапазон               |     эквивалентно выражению `exp1:exp2:1`        |
| `exp1 \|\| exp2`         |       3   |       левая     |       `bool`              |     логическое `ИЛИ`                            |
| `exp2 && exp2`           |       4   |       левая     |       `bool`              |     логическое `И`                              |
| `exp1 == exp2`           |       5   |       левая     |       `bool`              |     равенство                                   |
| `exp1 != exp2`           |       5   |       левая     |       `bool`              |     неравенство                                 |
| `exp1 < exp2`            |       5   |       левая     |       `bool`              |     меньше                                      |
| `exp1 <= exp2`           |       5   |       левая     |       `bool`              |     меньше или равно                            |
| `exp1 >= exp2`           |       5   |       левая     |       `bool`              |     больше или равно                            |
| `exp1 > exp2`            |       5   |       левая     |       `bool`              |     больше                                      |
| `elem :: list`           |       6   |       правая    |   как у `list`            |     сконструировать список                      |
| `exp1 \| exp2`           |       7   |       левая     |   как у аргументов        |     побитовое `ИЛИ`                             |
| `exp1 ^ exp2`            |       8   |       левая     |   как у аргументов        |     побитовое "исключающее `ИЛИ`"               |
| `exp1 & exp2`            |       9   |       левая     |   как у аргументов        |     побитовое `И`                               |
| `exp1 <=> exp2`          |       10  |       левая     |       `int`               |     оператор "космический корабль"              |
| `exp1 .cmpop exp2`       |       11  |       левая     |   коллекция `bool`        |     поэлементное сравнение                      |
| `exp1 .<=> exp2`         |       12  |       левая     |   коллекция `int`         |     поэлементный "космический корабль"          |
| `exp1 === exp2`          |       12  |       левая     |       `bool`              |     операция эквивалентности                    |
| `exp1 << exp2`           |       13  |       левая     |    как у `exp1`           |     сдвиг влево                                 |
| `exp1 >> exp2`           |       13  |       левая     |    как у `exp1`           |     сдвиг вправо                                |
| `exp1 + exp2`            |       14  |       левая     |    объединенный тип       |     сложение                                    |
| `exp1 - exp2`            |       14  |       левая     |    объединенный тип       |     вычитание                                   |
| `exp1 .+ exp2`           |       14  |       левая     |    объединенная коллекция |     поэлементное сложение                       |
| `exp1 .- exp2`           |       14  |       левая     |    объединенная коллекция |     поэлементное вычитание                      |
| `exp1 * exp2`            |       15  |       левая     |    объединенный тип       |     поэлементное умножение                      |
| `exp1 / exp2`            |       15  |       левая     |    объединенный тип       |     поэлементное деление                        |
| `exp1 % exp2`            |       15  |       левая     |    объединенный тип       |     знаковый остаток                            |
| `exp1 \ exp2`            |       15  |       левая     |    как у `exp1`           |     обратное деление                            |
| `seq * n`                |       15  |       левая     |    как у `seq`            |     повторить `seq` `n` раз                     |
| `n * seq`                |       15  |       левая     |    как у `seq`            |     повторить `seq` `n` раз                     |
| `exp1 .* exp2`           |       15  |       левая     |    объединенная коллекция |     поэлементное умножение                      |
| `exp1 ./ exp2`           |       15  |       левая     |    объединенная коллекция |     поэлементное деление                        |
| `exp1 ** exp2`           |       16  |       правая    |    объединенный тип       |     возведение в степень                        |
| `exp1 .** exp2`          |       16  |       правая    |    объединенная коллекция |     поэлементное возведение в степень           |
| `+exp, -exp`             |       17  |       правая    |    объединенный тип       |     унарный плюс, унарный минус                 |
| `.-exp`                  |       17  |       правая    |    объединенный тип       |     унарный точка-минус                         |
| `!exp`                   |       17  |       правая    |    `bool`                 |     логическое отрицание                        |
| `~exp`                   |       17  |       правая    |    как у `exp`            |     побитовое отрицание                         |
| `\exp`                   |       17  |       правая    |    N/A                    |     операция *развертывания*                    |
| `ref exp`                |       17  |       правая    |    ссылка                 |     создание ссылки с начальным значением `exp` |
| `exp'`                   |       18  |       левая     |    как у `exp`            |     транспонирование массива                    |
| `*exp`                   |       19  |       правая    |    тип по ссылке          |     разыменование ссылки                        |
| `exp1.name`              |       20  |       левая     |    тип члена              |     доступ к членам                             |
| `exp1->name`             |       20  |       левая     |    тип члена              |     разыменование и доступ                      |
| `exp1.X`                 |       20  |       левая     |    тип члена              |     доступ к полю `X` кортежа                   |
| `exp1->X`                |       20  |       левая     |    тип члена              |     разыменование и доступ                      |
| `exp1.{name2=exp2,...}`  |       20  |       левая     |    запись                 |     измененная копия записи                     |
| `exp1->{name2=exp2,...}` |       20  |       левая     |    запись                 |     как предыдущее, с разыменованием            |
| `exp1[exp2,exp3,...]`    |       20  |       левая     |    тип элемента           |     доступ к элементу или подмассиву            |
| `exp1(exp2,exp3,...)`    |       20  |       левая     |    тип возврата           |     вызов функции                               |
| `(exp1)`                 |       ∞   |       N/A       |    как у `exp1`           |     управление порядком вычислений              |
| `({code_block ...})`     |       ∞   |       N/A       |    тип последнего exp     |     как предыдущее                              |
| `(exp1, exp2, ...)`      |       ∞   |       N/A       |    кортеж                 |     создание кортежа                            |
| `[exp1, exp2, ...]`      |       ∞   |       N/A       |    массив                 |     создание массива                            |
| `[:: exp1, exp2, ...]`   |       ∞   |       N/A       |    список                 |     создание списка                             |
| `[for ...]`              |       ∞   |       N/A       |    массив                 |     построение массива                          |
| `[:: for ...]`           |       ∞   |       N/A       |    список                 |     построение списка                           |
| `(:: for ...)`           |       ∞   |       N/A       |    кортеж                 |     построение кортежа                          |
| `name1 {name2=exp2,...}` |       ∞   |       N/A       |    запись                 |     создание записи                             |


Как и в других языках, приоритеты операций и правила ассоциации часто уменьшают необходимость использования скобок `(` `)`, но при необходимости можете их использовать для изменения порядка вычислений. 

Что обозначает _объединенный тип_ в табице? Это тип, вычисляемый из `T1` и `T2`, достаточно широкий, чтобы избежать (в большинстве случаев) усечения результата операции. Развернутое определение объединения дается в разделе [Числа](#numbers).

Помимо основных операций, показанных в таблице, есть и другие, описанные в соответствующих разделах.

# Типы

Ficus &ndash; строгий статически типизированный язык. Каждое значение обладает типом, определяемым во время компиляции. Для значений и переменных типы часто выводятся автоматическии и обычно описание типа для них может быть опущено. Иногда требуется указать типы  явно, например, при объявлении функции требуется явно указать типы аргументов. Если значение не типизировано явно и компилятор не может вывести его тип, будет выдана ошибка. Это значит, что если программа скомпилировалась без ошибок, все значения получили тип.

Тип определяется следующим образом (кроме _классов_ и _интерфейсов_, у них свой синтаксис):

```
type typename = <тело типа>
```

Здесь `тело типа` это синоним типа, запись или вариант, например:

```
type point = (int, int)
type DComplex = {re: double; im: double}
type contour_t = point vector
```

Для обобщенных типов синтаксис чуть более сложный (см. [Обобщенное программирование](#generic-programming):

```
// тип с одним параметром
type 't typename = <тело типа>
или
// тип с несколькими параметрами
type ('t1, ..., 'tN) typename = <тело типа>
```

Например:

```
type 't Complex = {re: 't, im: 't}
type ('key, 'data) hashtable_t =
{
    hash_func: 'key -> uint64;
    table: (uint64, 'key, 'data) [] ref;
}
```
*Краткое замечание относительно нотации `'t`: идентификатор с префиксом `'` в рамках объявления типа задает обозначает так называемую типовую переменную. В терминах C++ это параметр шаблона `typename`. Когда тип инстанцируется, вместо `'t` должен подставляться конкретный тип. Если одно и то же имя в описании типа появляется несколько раз, это означает, что должен использоваться один и тот же тип во всех указанных местах. Если используются разные идентификаторы,они могут соответствовать разным конкретным типа, а могут быть и одним типом. Такая нотация немного отличается от других языков, где типовые аргументы идут за обобщенным типом в угловых скобках, например `vector<int>` в C++. В Ficus аргумент(ы) помещается спереди: `point vector`, `float Complex` и т.д.*

Вот как можно использовать ранее определенные не-обобщенные типы:

```
fun convexhull(c: contour_t): contour_t { ... }

// Контур представляется вектором пар целых.
val contour = vector([(0, 0), (10, 0), (1, 1), (0, 10)])

// Корректно: contour_t === point vector === (int, int) vector
// Тип cHull выводится автоматически
val cHull = convexhull(contour)
// Корректно: переопределяется значение 'contour' как (float Complex) vector.
// Предыдущий 'contour' сокрыт.
// Также нет необходимости объявлять тип
val contour =
      vector([Complex {re=0.f, im=0.f}, Complex {re=10.f, im=0.f},
              Complex {re=1.f, im=1.f}, Complex {re=0.f, im=10.f}])
// Некорректно: convexhull ожидает (int, int) vector.
val cHull_f = convexhull(contour)

fun conj(c: DComplex) = DComplex {re=c.re, im=-c.im}

// Неверно: Ожидается DComplex, предоставлено 'double Complex'.
// Обе структуры имеют одинаковый состав,
// но разные наименования.
val xc = conj(Complex {re=5., im=1.})

// Задается синоним экземпляра hashtable_t
type phonebook_t = (string, int) hashtable_t

// Задается функция, используютщая другой экземпляр hashtable_t
fun translate(word: string, dict: (string, string) hashtable_t)
{ ... }
```
