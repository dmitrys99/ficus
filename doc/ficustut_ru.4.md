## Ранний выход с помощью return

Ficus поддерживает оператор `return`, позволяющий выйти из функции раньше с возможным возвращением значения. Подобно любому другому оператору управления потоком в Ficus, `return` является выражением. Само выражение `return` имеет тип `void`, вне зависимости от того, возвращает оно значение или нет.

```
fun foo(arg1: t1, ..., argn: tn) {
    ...
    if some_expr { return some_value }
    ...
    match another_expr {
    ...
    | pattern => return another_value
    ... // остальные действия должны иметь тип void
    }
    final_ret_value // финальное выражение
}
```

В данном примере значения `some_value`, `another_value` и `final_ret_value` должны иметь одинаковый тип. Если функция имеет тип `void`, то все операторы return в ней должны применяться без возвращения значения.

# Числа

Набор числовых типов и операций с ними в Ficus схож с языками C/C++ и с большинством других языков программирования.

Одно существенное отличие от C/C++ и Python касается типа `int`. В C/C++ тип `int` чаще всего представляет собой 32-битное целое число, даже на 64-битных машинах. В Python начиная с версии 3.x тип `int` — это целое число произвольной точности. В Ficus тип `int` на 32-битных машинах является 32-битным числом, а на 64-битных — 64-битным. Важное замечание: в Ficus нет типа `uint` или `unsigned`.

Числовые типы не преобразуются друг в друга неявно. Например, если функция принимает аргумент типа `int`, а у вас имеется значение типа `uint8`, его нужно явно привести к типу `int`. Существуют три способа приведения числа из одного типа в другой:

1. через оператор приведения типа `(expr :> целевой_тип)`:

```
val a = 34587345
val b = 987654321
val product = (a :> uint64) * b
```

(Оператор `:>` универсален и может также использоваться для преобразования чисел в строки, запроса интерфейсов класса и т.п.; подробности см. в разделе [Объектно-ориентированное программирование]().)

2. через специальную функцию преобразования: `целевое_имя_типа()` или `sat_целевое_имя_типа()`, например, `int8()` преобразует число в тип `int8`. Мы уже встречали функцию `string()`, которая преобразует различные значения в строку. Функции вида `sat_[u]intN()` выполняют преобразование с насыщением, то есть обрезают аргумент вместо простого отбрасывания младших бит:

```
// псевдо-реализация sat_uint8()
fun sat_uint8(x: int) =
    if x < 0 {0u8} else if x > 255 {255u8} else {uint8(x)}
```

3. конверсия вещественного числа в целое — особый случай, для этого предусмотрены несколько функций:

* `round()` — округление к ближайшему числу
* `floor()` — округление к минус бесконечности
* `ceil()` — округление к плюс бесконечности
* `trunc()` — округление к нулю, аналогично C

Стандартный набор арифметических, поразрядных и сравнительных операторов в Ficus повторяет большинство других языков. Полный перечень доступных операций смотрите в разделе [Выражения]().

Аргументы бинарных операций могут иметь разные типы, в таких случаях применяются правила повышения типов, то есть оба аргумента приводятся к общему, достаточно широкому типу:

1. до приведения, если `T1` или `T2` является типом `int8`, `uint8`, `int16` или `uint16`, он приводится к типу `int`.
2. если оба типа совпадают (возможно, после предыдущего шага), результатом повышения будет именно этот общий тип.
3. иначе, если один из типов — целое число, а другой — вещественное, результатом станет вещественный тип.
4. если один из типов — `int` или `int32`, а другой — `int64`, результатом будет `int64`.
5. если один из типов — `uint32`, а другой — `int64` или `uint64`, результатом будет `int64` или `uint64`.
6. если один из типов — `float`, а другой — `double`, результатом будет `double`.
7. в противном случае проверщик типов выдаст ошибку, и нужно явно приводить аргументы к паре согласуемых типов.

Правила повышения применяются рекурсивно для массивов и кортежей при операциях `.+`, `.-`, `.*`, `./`, при этом обработка осуществляется поэлементно.

Кроме того, есть полезные функции, работающие с числами:

* `min(a, b)`, `max(a, b)` — находят минимум/максимум двух чисел
* `abs(x)` — вычисляет абсолютное значение аргумента
* `sign(x)` — вычисляет знак аргумента (-1, 0 или 1)
* `sqr(x)` — возводит аргумент в квадрат, то есть x*x
* `sqrt(x)` — извлекает квадратный корень
* `sin(x)`, `cos(x)`, `exp(x)`, `log(x)`, `atan2(y, x)` и прочие стандартные математические функции из модуля Math, подключаемого автоматически.

# Кортежи и записи

## Кортежи

Кортеж — это упорядоченная коллекция элементов фиксированного размера. Размер кортежа и типы его элементов известны на стадии компиляции. Элементами кортежа могут быть другие типы, включая сами кортежи, и кортежи могут быть вложены в другие типы:

```
type quaternion = (float, float, float, float) // или (float*4)
type color_t = (uint8*3) // сокращение для (uint8, uint8, uint8)
type label_t = (string, color_t)
type graph_t = (int, int list) list
```

Кортежи формируются путём помещения двух или более элементов, разделённых запятыми, в круглые скобки:

```
val q: quaternion = (1.f, 0.f, 0.f, 0.f)
// явно указали тип, но это не обязательно
val magenta : color_t = (255u8, 0, 255u8)
// другое указание типа кортежа
val yellow : (uint8*3) = (255u8, 255u8, 128u8)
val label = ("car", magenta)
```

Как уже отмечалось, кортежи могут использоваться анонимно, без явного указания типа. Однако можно задать удобные синонимы, как показано выше.

Доступ к элементам кортежа осуществляется с помощью нотации tuple_expr.целочисленный_литерал. Можно также распаковывать кортежи:

```
val (q_re, qi, qj, qk) = q
val (r, g, b) = magenta

val channel_idx = 1
// правильный способ извлечь элемент кортежа
fun channel(c: color, idx: int) =
   if idx == 0 {c.0}
   else if idx == 1 {c.1}
   else if idx == 2 {c.2}
   else {throw OutOfRangeError}

val label_name = label.0
val label_color = label.1
val i = i1.0
```

### Кортежи как короткие числовые векторы

В Ficus отсутствуют отдельные типы для коротких числовых векторов, точек, комплексных чисел, кватернионов, пикселей RGB и прочего. Вместо этого предлагается использовать кортежи. Например, кортеж типа `(uint8, uint8, uint8)` занимает 3 байта и столь же эффективен, как встроенный тип пикселя RGB, будь он доступен.

Для упрощения работы с такими типами в стандартной библиотеке Ficus определены базовые операции над подобными кортежами, в частности:

* арифметические операции:
  * поэлементные: `.+`, `.-`, `.*`, `./`
  * `*` над 2-компонентными кортежами дает произведение комплексных чисел, `/` - деление комплексных чисел
  * `*` над 4-компонентными кортежами дает произведение кватернионов
* операции сравнения: кортежи сравниваются лексикографически
* `norm()`: вычисляет корень суммы квадратов элементов кортежа
* `dot()`: скалярное произведение
* `cross()`:  векторное произведение для 3-компонентных кортежей: cross()
* печать и преобразование в строку: `print()`, `string()`
* другие операции, полный список см. Builtins.fx.

### Вложенные кортежи

Кортежи могут содержать произвольные элементы, включая другие кортежи. Доступ к элементам вложенных кортежей осуществляется аналогичным способом:

```
fun transform(Rt: ((double*3)*2), pt: (double*2)) =
    (Rt.0.0*pt.0 + Rt.0.1*pt.1 + Rt.0.2,
     Rt.1.0*pt.0 + Rt.1.1*pt.1 + Rt.1.2)
val a = 30*M_PI/180
val Rt = ((cos(a), -sin(a), 10.), (sin(a), cos(a), 0.))
val pt1 = (1., 0.)
println(transform(Rt, pt1))
```

Несмотря на возможное замешательство, вызванное наличием дробных чисел после кортежей, парсер решает проблему корректно. Пример иллюстрирует, что кортежи могут представлять небольшие матрицы, а не только векторы.

### Изменение кортежей

До сих пор мы рассматривали способы построения и чтения кортежей. Теперь разберёмся, как их изменять. Кортежи — неизменяемые структуры данных, поэтому непосредственно заменить их элементы нельзя. Однако, если у вас есть переменная типа кортежа (`var`), вы можете присвоить ей новый кортеж:

```
var vec = (1.f, 0.f, 0.f)
// "Изменим" второй элемент, создав новый кортеж
vec = (vec.0, vec.1 + 0.1f, vec.2)
```

Поскольку это не совсем эффективно, компилятор допускает изменение отдельных элементов, имитируя полную замену кортежа новым:

```
var vec = (1.f, 0.f, 0.f)
// Меняем только второй элемент
vec.1 += 0.1f
```

Это не нарушает правила "неизменяемости кортежей", а скорее служит оптимизацией с добавлением удобной синтаксической оболочки.

Эта оптимизация и удобный синтаксис применимы ко всем ситуациям, когда кортеж хранится в изменяемом расположении:

* в переменной
* в элементе массива
* в ссылаемой величине (см. раздел [Ссылки]())

## Записи

Запись похожа на кортеж, но её элементы (называемые полями) имеют имена и доступ к элементам осуществляется по имени. Записи не могут быть анонимными, они должны быть определены явно.

Записи формируются с помощью нотации `{ имя1=значение1, ..., имяN=значениеN }`, а доступ к полям осуществляется через конструкцию `expr.имя_поля`. Записи также можно распаковывать:

```
type rect_t = {x: int; y: int; width: int; height: int}
val r = rect { x=10, y=5, width=30, height=60 }
val r_area = r.width*r.height

type object_t // '=' можно пропустить перед '{'
{
    box: rect_t // разделяйте поля символом ';' или переходом на новую строку
    velocity: (int, int)
    id: int=-1 // некоторым полям записей можно задать значения по умолчанию
    label=(string, (uint8*3))
    tracked: bool=true
}

// Порядок полей может быть произвольным при создании записи
val obj = object_t {
  box=r, id=5, velocity=(0, 0),
  label=("", (255u8, 255u8, 255u8))
  // используем значение по умолчанию для поля "tracked"
}
// Игнорируем метку и флаг отслеживания,
// считывая только рамку и скорость
// Сокращение "id" вместо "id=id"
val { box=r, id, velocity=(vx, vy) } = obj
```

Заметим, что при создании записи нужно явно указывать имя типа, так как это позволяет компилятору однозначно определить, какую конкретно запись вы имеете в виду, какие поля она содержит и какая реальная последовательность полей используется.

Но при распаковке записи компилятор уже знает тип распаковываемого значения, поэтому тип записи опускается.

### Изменение/обновление записи

Хотя кортежи обычно невелики и редко нуждаются в частичных изменениях, для записей это утверждение неверно, и простое обновление отдельного поля может потребовать написания большого количества кода, особенно если меняется только одно поле. Для решения этой проблемы в Ficus предусмотрено удобное средство обновления записей — оператор `. {...}`:

```
type Rect = {x: int; y: int; width: int; height: int}
val r0 = Rect {x=0, y=0, width=100, height=50}
val r1 = r0.{x = r0.x + 10} // r1 совпадает с r0, за исключением изменённой координаты x
type object_t = {
    id: int=-1;
    box: rect_t;
    velocity: (int, int)
}
val obj = object_t {box=r1, velocity=(10, 5)}
// здесь обновление записи распространяется на вложенные записи
var moved_obj = obj.{
    box = obj.box.{
       x = obj.box.x + obj.velocity.0,
       y = obj.box.y + obj.velocity.1
       }
    }
// запись rec .= {обновляемые_элементы} — это сокращение для
// rec = rec . {обновляемые_элементы}
moved_obj .= {velocity=moved_obj.velocity/2}
```

Оператор `.=` -- это сокращенная форма записи для выражения `rec = rec . {поле = значение}`

Также отдельные элементы записи могут быть изменены в тех же ситуациях, что и кортежи:

* если запись хранится в переменной
* если запись находится в массиве записей
* если имеется ссылка на запись

Можно считать это своего рода оптимизацией.

### Работа с записью и кортежем, хранящимися по ссылке

Если у нас есть ссылка на кортеж или запись, мы можем сначала разыменовать ссылку и затем применить оператор . для доступа или модификации структуры (включая оператор обновления записи):

```
val r = ref (Rect {x=1, y=1, width=10, height=10})
println((*r).width*(*r).height)
```

Но существует удобная альтернатива, аналогичная C/C++:

```
...
println(r->width*r->height)
*r = r->{x = r->x + 5, y = r->y + 5}
r->x -= 5
r->y -= 5
```

Конструкция `rec->что-то` эквивалентна `(*rec).что-то` во всех случаях, и то же справедливо для кортежей.

### Изменяемые поля записи

Предположим, что запись представляет сложную структуру данных, такую как трекер объектов, состоящий из множества членов. Часть из них может быть постоянными параметрами алгоритма, другие члены могут меняться периодически, третьи отражают текущее состояние трекера, постоянно изменяющееся.

Такая запись может храниться в переменной (`var`), что позволяет обновить её. Однако, если вы захотите реализовать функцию, обновляющую трекер (например, реализацию самого алгоритма трекинга), сама функция не сможет изменить параметры записи, так как параметры функций неизменяемы. Она может лишь построить свежую обновленную структуру и вернуть её. Это хороший чисто функциональный стиль, но слегка неэффективный и громоздкий.

Альтернативой может стать хранение записи в виде ссылки, что упростило бы обновление. Тогда даже неизменяемые поля могли бы быть изменены, а код стал бы немного сложнее благодаря замене всех обращений через точку (`.`) на стрелочку (`->`).

Частичным решением может стать объявление некоторых полей записи как изменяемых с помощью спецификатора `var`, например:

```
type Tracker =
{
    // некоторые параметры алгоритма
    eps: double
    search_radius: int = 20
    // текущее состояние
    var objs: object_t []
}

fun track(tracker: Tracker, detector: Detector, image: uint8 [,])
{
    ...
    for obj@i <- tracker.objs {
    // обновляем местоположение i-го объекта
        ...
    }
    if size(newly_tracked_obj) != 0 {
        // конкатенируем два массива;
        // подробности см. в разделе 'Массивы'
        tracker.objs = [\tracker.obj, \newly_detected_objs]
    }
}
```

Важно отметить, что запись с хотя бы одним изменяемым полем всегда размещается в куче, что накладывает дополнительные издержки на использование изменяемых полей. Но затраты ниже, чем превращение нескольких полей записи в ссылки для возможности их изменения. Можете представить запись с изменяемыми полями как ссылку на запись, где поля без спецификатора `var` защищены от изменения. Или думать о ссылке как о записи с единственным изменяемым полем (этот подход принят в OCaml). Подробности см. в разделе [Ссылки]().

# Массивы

Ficus разработан специально для числовой обработки, поэтому в нём обеспечена хорошая поддержка многомерных массивов.

Многомерный массив — встроенный тип в Ficus, обозначаемый как `'t [, ...]`, где количество запятых соответствует размерности массива минус единица. Многомерные массивы хранятся в памяти подряд в порядке строк (аналогично C/C++ и в отличие от Fortran и MATLAB, где используется порядок столбцов), и они не являются массивами массивов.

Массивы всегда требуют явной инициализации, подобно остальным типам в Ficus. Ниже приведены возможные способы создания и инициализации массивов:

```
// Создадим массив 480x640 восьмибитных чисел,
// пригодный для представления серого изображения.
// Инициализируем элементы нулями.
val image = array((480, 640), 0u8)

// Построим другое изображение, выполнив арифметическую операцию
val lighter_image = image .+ 100u8

val phi = M_PI/3
val (a, b) = (cos(phi), sin(phi))
// Создадим матрицу поворота 2x2, явно указав все её элементы
val R = [a, -b; b, a]
val RR = R*R // произведём умножение матриц
val shift = (100., 10.)
// Составим аффинную матрицу 2x3:
// левый блок 2x2 будет инициализирован R,
// правый блок 2x1 — смещающим вектором
val affine = [\R, $$shift.0; shift.1]]

// Используя comprehension
val gradient = [for y <- 0:256 for x <- 0:256
                  { sat_uint8((x, y, (x+y)/2)) }]
```

Создав массив, мы можем легко читать и изменять его:

```
fun sumpixels(img: uint8 [,]): int =
    // Итерация по массиву с помощью цикла for
    fold sum=0 for x <- img {sum + x}

// Выделим интересующую область (ROI);
// данные не копируются, а совместно используются
val roi = image[50:100, 300:400]
// Подсчитаем сумму пикселов в ROI
val sum_roi = sumpixels(roi)

// Изменим ROI; родительское изображение изменится тоже
val (m, n) = size(roi)
for y <- 0:m
  for x <- 0:n {
     roi[y, x] ^= 255u8
  }
```

Отметим, что элементы `roi` могут быть изменены, даже если сам `roi` является значением. Это связано с тем, что массивы — изменяемые структуры.

Массивы индексируются с помощью нотации `arr[idx_or_range1, idx_or_range2, ...]`, где каждый `idx_or_rangej` — это либо целое число (индекс), либо диапазон `[start]:[end]:[step]`, где любой из компонентов `start`, `end` или `step` может отсутствовать, либо двоеточие `:`, означающее "взять все элементы вдоль этой оси (всё поле, весь столбец и т.д.)":

```
// создадим ненормализованную матрицу Адамара
fun Hadamard(n: int, one: 't): 't [,] {
    assert(n & (n-1) == 0)
    if n == 1 { [for i <- 0:1 for j <- 0:1 {one}] }
    else { val h = Hadamard(n/2, one); [\h, \h; \h, $-h)] }
}

val mtx = Hadamard(8, 1.)

// возьмём пятую строку матрицы, умножим все элементы на 2
// и прибавим полученный продукт к первой строке той же матрицы
mtx[1, :] += mtx[5, :]*2
```

Такие матричные преобразования возможны, поскольку операция выделения подмассива не копирует никаких данных. Вместо этого формируется новая заголовочная структура, инициализируется её размер, тип и размерность, а затем она указывает на оригинальную память массива с некоторым смещением. Счётчик ссылок оригинальной памяти увеличивается. Есть два исключения из этого правила:

* если в диапазоне подмассива использован отрицательный шаг или ненулевой шаг в последней размерности, то подмассив нужно скопировать в новое место.
* выполнена пперация `flatten` (`arr[:]`), а массив не непрерывен. В этом случае данные также подлежат копированию.

Когда подмассив больше не нужен, он разрушается, счётчик ссылок уменьшается.

## Обращение к элементам массива

Когда в программе встречается обращение к элементу массива `A[i, j, k, ...]`, компилятор Ficus генерирует код, аналогичный следующему псевдокоду:

```
if (i < 0 || i >= A.size[0] ||
   j < 0 || j >= A.size[1] ||
   k < 0 || k >= A.size[2] ||
   ...) {
    __throw__(OutOfRangeError);
}
elemtype* ptr = (elemtype*)(A.data + A.step[0]*i +
                   A.step[1]*j + A.step[2]*k + ... );
```

То есть каждая операция обращения к элементу проверяет, находится ли индекс элемента в границах массива. Если индекс выходит за пределы, возникает исключение `OutOfRangeError`. Хотя это повышает безопасность и помогает быстро выявить ошибки, это может замедлить доступ к массивам. В случае выбора диапазонов вместо конкретных индексов границы также проверяются, но накладные расходы заметно ниже.

Для повышения производительности и сохранения безопасности компилятор Ficus применяет особые оптимизации, уменьшая количество проверок границ:

* если внутри цикла `for` обращение к массиву выполняется  безусловным образом (то есть не внутри вложенных операторов if, match, try и т.д.)
* и если индекс `ij` является линейной комбинацией индекса цикла и некоторых инвариантов цикла: `ij == loop_idx*loop_inv + another_loop_inv`

тогда проверка границ перемещается за пределы цикла и заменяется проверкой, попадают ли наименьший и наибольший индексы цикла в границы массива.

Рассмотрим пример реализации функции умножения матриц, приведённой ранее:

```
fun matmul(A: double [,], B: double [,])
{
    val (ma, na) = size(A), (mb, nb) = size(B)
    assert(na == mb)
    [for i <- 0:ma for j <- 0:nb {
        fold s = 0. for k <- 0:na {s + A[i,k]*B[k,j]}
     }]
}
```

Генерируемый код (псевдокод на языке Ficus) выглядел бы так:

```
fun matmul(A: double [,], B: double [,])
{
    val (ma, na) = size(A), (mb, nb) = size(B)
    assert(na == mb)
    // Проверяем границы массива для индексов i и j
    check_range(0, ma, 1, 0, A, 0)
    check_range(0, nb, 1, 0, B, 1)
    [for i <- 0:ma for j <- 0:nb {
        // Аналогично проверяем индекс k
        check_range(0, na, 1, 0, A, 1)
        check_range(0, na, 1, 0, B, 0)
        // <.> обозначает быстрый доступ без проверки границ,
        // это не реальный синтаксис Ficus
        fold s = 0. for k <- 0:na {s + A[<i>,<k>]*B[<k>,<j>]}
     }]
}
```

Теоретически следующая версия компилятора могла бы переместить последние две проверки за пределы внешнего цикла.

Более быстрым методом доступа к элементам массива является их запрос прямо в заголовке цикла for, например:

```
// здесь x извлекается с помощью *(указатель_на_субмассив + индекс_цикла) на уровне C-кода
fold sum = 0. for x <- arr {s + x}
```

Преимущества такого подхода:

* проверка границ не требуется, так как известно, что мы проходим по всему массиву.
* адрес элемента не нужно вычислять заново, достаточно увеличить счетчик  цикла и простым действием обратиться к элементу. Особенно полезно это в случае прохода по двумерной матрице, когда перед внутренним циклом устанавливается указатель на текущую строку матрицы, а затем он используется как базовый указатель, добавляясь к счетчику цикла для получения текущего элемента матрицы. Такой подход необходим, поскольку матрица не обязана быть смежной (может быть подматрицей большей матрицы).

Следовательно, если нам нужны как элемент, так и его индекс, эффективнее запрашивать их оба в заголовке цикла for, чем обращаться к элементу через оператор `[]`.
